ğŸ—‚ DeepType Codebase Dump
ğŸ“… Generated on: Tue Feb 25 05:23:01 PST 2025
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ Core System Files
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“‚ Component Files
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸŸ¦ File: src/components/word-exploration.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { motion, AnimatePresence } from "framer-motion";
import DOMPurify from "dompurify";
import { SectionalErrorBoundary } from "@/lib/error-handling/error-boundaries";
import { useErrorHandling } from "@/context/error-context";

/**
 * WordExploration component
 *
 * This component allows users to explore words, showing related terminology,
 * etymology, and usage examples in a visual card format.
 */
export function WordExploration() {
  return (
    <SectionalErrorBoundary>
      <WordExplorationContent />
    </SectionalErrorBoundary>
  );
}

/**
 * WordExplorationContent component
 *
 * The actual implementation of the word exploration functionality.
 * Separated from the main component to allow error boundary wrapping.
 */
function WordExplorationContent() {
  // Error handling
  const { captureError } = useErrorHandling();

  // State for input and results
  const [inputWord, setInputWord] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [wordData, setWordData] = useState<WordData | null>(null);

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputWord.trim()) return;

    setIsLoading(true);

    try {
      // Call our API endpoint
      const response = await fetch(`/api/explore-word?word=${encodeURIComponent(inputWord)}`);

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Error: ${response.status}`);
      }

      const data = await response.json();
      setWordData(data);

      // Log for debugging
      console.log("Fetched word data:", data);
    } catch (error) {
      console.error("Error exploring word:", error);

      // Use our error handling context
      captureError(
        error instanceof Error ? error : new Error(String(error)),
        "WordExplorationContent.handleSubmit"
      );

      toast.error(error instanceof Error ? error.message : "Failed to explore this word. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  // Handle copying word data to clipboard
  const handleCopy = (text: string) => {
    try {
      navigator.clipboard.writeText(text);
      toast.success("Copied to clipboard");
    } catch (error) {
      console.error("Failed to copy:", error);
      toast.error("Failed to copy to clipboard");

      // Use our error handling context
      captureError(
        error instanceof Error ? error : new Error(String(error)),
        "WordExplorationContent.handleCopy"
      );
    }
  };

  // Handle exporting word data as markdown
  const handleExportMarkdown = () => {
    if (!wordData) return;

    try {
      const markdown = generateMarkdown(wordData);
      navigator.clipboard.writeText(markdown);
      toast.success("Markdown copied to clipboard");
    } catch (error) {
      console.error("Failed to export markdown:", error);
      toast.error("Failed to export markdown");

      // Use our error handling context
      captureError(
        error instanceof Error ? error : new Error(String(error)),
        "WordExplorationContent.handleExportMarkdown"
      );
    }
  };

  // Generate markdown from word data
  const generateMarkdown = (data: WordData): string => {
    let md = `# ${data.word}\n\n`;
    md += `## Core Meaning\n${data.coreMeaning}\n\n`;
    md += `## Etymology\n${data.etymology}\n\n`;
    md += `## Related Words\n`;

    data.relatedWords.forEach((related) => {
      md += `- **${related.word}** (${related.type}): ${related.meaning}\n`;
    });

    md += `\n## Usage Trends\n`;
    md += `Popularity: ${data.usageTrends.popularity}/10\n\n`;
    md += `### Common Contexts\n`;
    data.usageTrends.contexts.forEach((context) => {
      md += `- ${context}\n`;
    });

    return md;
  };

  return (
    <div className="w-full space-y-6 md:space-y-8">
      {/* Search Form */}
      <form onSubmit={handleSubmit} className="w-full flex flex-col gap-2">
        <div className="flex flex-col sm:flex-row gap-2">
          <div className="relative flex-grow">
            <input
              type="text"
              value={inputWord}
              onChange={(e) => setInputWord(e.target.value)}
              placeholder="Enter a word to explore..."
              className="w-full px-4 py-3 bg-background/50 border border-border rounded-lg
                        focus:outline-none focus:ring-2 focus:ring-primary/20 transition-all
                        glass-effect text-base md:text-lg"
              disabled={isLoading}
              aria-label="Word to explore"
            />
            {isLoading && (
              <div className="absolute right-3 top-1/2 -translate-y-1/2">
                <div className="h-5 w-5 border-2 border-primary/30 border-t-primary rounded-full animate-spin"></div>
              </div>
            )}
          </div>
          <Button
            type="submit"
            disabled={isLoading || !inputWord.trim()}
            className="whitespace-nowrap transition-all py-6 px-6"
          >
            Explore
          </Button>
        </div>
        <p className="text-xs text-muted-foreground text-center sm:text-left">
          Try words like &quot;eloquent&quot;, &quot;vibrant&quot;, or &quot;serendipity&quot;
        </p>
      </form>

      {/* Results */}
      <AnimatePresence mode="wait">
        {wordData && !isLoading && (
          <motion.div
            key={wordData.word}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.5 }}
            className="space-y-6 md:space-y-8"
          >
            {/* Word Title */}
            <div className="text-center">
              <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold tracking-tight mb-2">
                {wordData.word}
              </h1>
              <div className="flex justify-center gap-2 mt-4">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleCopy(wordData.word)}
                  className="text-xs"
                >
                  Copy Word
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleExportMarkdown}
                  className="text-xs"
                >
                  Export to MD
                </Button>
              </div>
            </div>

            {/* Core Meaning */}
            <div className="glass-effect p-4 sm:p-6 rounded-xl">
              <h2 className="text-lg sm:text-xl font-semibold mb-2 sm:mb-3 text-primary">Core Meaning</h2>
              <p className="text-sm sm:text-base text-muted-foreground">{wordData.coreMeaning}</p>
            </div>

            {/* Etymology */}
            <div className="glass-effect p-4 sm:p-6 rounded-xl">
              <h2 className="text-lg sm:text-xl font-semibold mb-2 sm:mb-3 text-primary">Etymology</h2>
              <p className="text-sm sm:text-base text-muted-foreground">{wordData.etymology}</p>
            </div>

            {/* Related Words */}
            <div>
              <h2 className="text-lg sm:text-xl font-semibold mb-3 sm:mb-4 text-primary">Related Words</h2>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                {wordData.relatedWords.map((related, index) => (
                  <div
                    key={index}
                    className="glass-effect p-3 sm:p-4 rounded-xl cursor-pointer hover:shadow-md transition-all active:scale-95"
                    onClick={() => handleCopy(related.word)}
                  >
                    <div className="flex justify-between items-start mb-1 sm:mb-2">
                      <h3 className="font-medium text-base sm:text-lg">{related.word}</h3>
                      <span className="bg-primary/10 text-primary text-xs px-2 py-1 rounded">
                        {related.type}
                      </span>
                    </div>
                    <p className="text-xs sm:text-sm text-muted-foreground">{related.meaning}</p>
                  </div>
                ))}
              </div>
            </div>

            {/* Usage Trends */}
            <div className="glass-effect p-4 sm:p-6 rounded-xl">
              <h2 className="text-lg sm:text-xl font-semibold mb-2 sm:mb-3 text-primary">Current Usage</h2>
              <div className="mb-4">
                <div className="flex justify-between mb-1">
                  <span className="text-xs sm:text-sm text-muted-foreground">Popularity</span>
                  <span className="text-xs sm:text-sm font-medium">{wordData.usageTrends.popularity}%</span>
                </div>
                <div className="w-full bg-muted/30 rounded-full h-2">
                  <div
                    className="bg-gradient-to-r from-purple-600 to-blue-500 h-2 rounded-full"
                    style={{ width: `${wordData.usageTrends.popularity}%` }}
                  ></div>
                </div>
              </div>
              <div>
                <h3 className="text-xs sm:text-sm font-medium mb-2">Common Contexts</h3>
                <div className="flex flex-wrap gap-2">
                  {wordData.usageTrends.contexts.map((context, index) => (
                    <span
                      key={index}
                      className="bg-background/50 text-muted-foreground text-xs px-3 py-1 rounded-full"
                    >
                      {context}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

// Types
interface WordData {
  word: string;
  coreMeaning: string;
  etymology: string;
  relatedWords: {
    word: string;
    type: string;
    meaning: string;
  }[];
  usageTrends: {
    popularity: number;
    contexts: string[];
  };
}```


ğŸŸ¦ File: src/components/ui/waitlist-form.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { checkWaitlistEmail } from "@/lib/waitlist-storage";

interface WaitlistFormProps {
  className?: string;
}

/**
 * WaitlistForm component
 *
 * This component handles email collection for the waitlist,
 * with validation, duplicate checking, and smooth feedback.
 */
export function WaitlistForm({ className }: WaitlistFormProps) {
  // State management
  const [email, setEmail] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [submissionError, setSubmissionError] = useState<string | null>(null);

  // Email validation
  const isValidEmail = (email: string) => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  };

  // Form submission handler
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmissionError(null);

    // Validate email format
    if (!isValidEmail(email)) {
      toast.error("Please enter a valid email address");
      setSubmissionError("Invalid email format");
      return;
    }

    try {
      setIsSubmitting(true);

      // First check if the email already exists in the waitlist
      console.log(`ğŸ” Checking if email already exists: ${email}`);
      const exists = await checkWaitlistEmail(email);

      if (exists) {
        console.log(`ğŸ“‹ Email already in waitlist: ${email}`);
        toast.info("This email is already on our waitlist!");
        setIsSubmitted(true);
        setEmail("");
        return;
      }

      // Send the email to the API
      console.log(`ğŸ“ Submitting email to waitlist: ${email}`);
      const response = await fetch("/api/waitlist", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });

      // Parse the JSON response properly
      const data = await response.json();

      // Check if the request was successful
      if (!response.ok) {
        throw new Error(data.message || "Failed to join waitlist");
      }

      // Handle success
      console.log(`âœ… Successfully added to waitlist: ${email}`);
      setIsSubmitted(true);
      setEmail("");
      toast.success("You've been added to our waitlist!");
    } catch (error) {
      // Handle errors gracefully
      console.error("Waitlist submission error:", error);
      setSubmissionError(error instanceof Error ? error.message : "Submission failed");
      toast.error(error instanceof Error ? error.message : "Failed to join waitlist. Please try again.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className={cn("w-full", className)}>
      {isSubmitted ? (
        // Success state
        <div className="text-center space-y-2 p-4 glass-effect rounded-lg">
          <h3 className="text-lg font-medium text-primary">Thank you for joining!</h3>
          <p className="text-sm text-muted-foreground">
            We&apos;ll notify you when Deep Wordsmith is ready.
          </p>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setIsSubmitted(false)}
            className="mt-2"
          >
            Join with another email
          </Button>
        </div>
      ) : (
        // Form state
        <form onSubmit={handleSubmit} className="space-y-2">
          <div className="flex flex-col sm:flex-row gap-2">
            <div className="relative flex-grow">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value.trim())}
                placeholder="Enter your email"
                className={cn(
                  "w-full px-4 py-2 bg-background/50 border rounded-lg",
                  "focus:outline-none focus:ring-2 focus:ring-primary/20 transition-all",
                  "glass-effect",
                  submissionError ? "border-red-500 focus:ring-red-200" : "border-border"
                )}
                disabled={isSubmitting}
                aria-label="Email address"
                required
              />
              {isSubmitting && (
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  <div className="h-4 w-4 border-2 border-primary/30 border-t-primary rounded-full animate-spin"></div>
                </div>
              )}
            </div>
            <Button
              type="submit"
              disabled={isSubmitting || !email.trim()}
              className="whitespace-nowrap transition-all"
            >
              {isSubmitting ? "Submitting..." : "Join Waitlist"}
            </Button>
          </div>
          {submissionError ? (
            <p className="text-xs text-red-500 text-center sm:text-left">
              {submissionError}
            </p>
          ) : (
            <p className="text-xs text-muted-foreground text-center sm:text-left">
              We&apos;ll notify you when Deep Wordsmith is ready. No spam.
            </p>
          )}
        </form>
      )}
    </div>
  );
}```


ğŸŸ¦ File: src/components/semantic-graph-visualization.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { useRef, useEffect, useState, useCallback } from "react";
import { ForceGraph2D } from "react-force-graph";
import { SemanticGraph, SemanticNode, SemanticLink, DEFAULT_GRAPH_CONFIG } from "@/types/semantic-graph";
import { SectionalErrorBoundary } from "@/lib/error-handling/error-boundaries";
import { useErrorHandling } from "@/context/error-context";
import { toast } from "sonner";

/**
 * Props for the SemanticGraphVisualization component
 */
interface SemanticGraphVisualizationProps
{
  word?: string;
  className?: string;
}

/**
 * SemanticGraphVisualization component
 *
 * This component displays a force-directed graph visualization of semantic relationships
 * between words. It fetches data from the semantic-graph API endpoint.
 */
export function SemanticGraphVisualization ( { word, className = "" }: SemanticGraphVisualizationProps )
{
  return (
    <SectionalErrorBoundary>
      <SemanticGraphVisualizationContent word={ word } className={ className } />
    </SectionalErrorBoundary>
  );
}

/**
 * SemanticGraphVisualizationContent component
 *
 * The actual implementation of the semantic graph visualization.
 * Separated from the main component to allow error boundary wrapping.
 */
function SemanticGraphVisualizationContent ( { word, className = "" }: SemanticGraphVisualizationProps )
{
  // Error handling
  const { captureError } = useErrorHandling();

  // State for graph data and UI
  const [ graphData, setGraphData ] = useState<SemanticGraph | null>( null );
  const [ isLoading, setIsLoading ] = useState<boolean>( false );
  const [ selectedNode, setSelectedNode ] = useState<SemanticNode | null>( null );
  const [ dimensions, setDimensions ] = useState( { width: 800, height: 600 } );

  // Refs
  const containerRef = useRef<HTMLDivElement>( null );
  const graphRef = useRef<any>( null );

  // Fetch graph data when word changes
  useEffect( () =>
  {
    if ( !word )
    {
      setGraphData( null );
      return;
    }

    const fetchGraphData = async () =>
    {
      setIsLoading( true );

      try
      {
        console.log( `Fetching semantic graph for word: ${ word }` );
        const response = await fetch( `/api/semantic-graph?word=${ encodeURIComponent( word ) }` );

        if ( !response.ok )
        {
          const errorData = await response.json();
          throw new Error( errorData.message || `Error: ${ response.status }` );
        }

        const data = await response.json();
        console.log( "Fetched semantic graph data:", data );
        setGraphData( data );
      } catch ( error )
      {
        console.error( "Error fetching semantic graph:", error );

        captureError(
          error instanceof Error ? error : new Error( String( error ) ),
          "SemanticGraphVisualization.fetchGraphData"
        );

        toast.error( error instanceof Error ? error.message : "Failed to load semantic graph" );
      } finally
      {
        setIsLoading( false );
      }
    };

    fetchGraphData();
  }, [ word, captureError ] );

  // Update dimensions on resize
  useEffect( () =>
  {
    const updateDimensions = () =>
    {
      if ( containerRef.current )
      {
        const { width, height } = containerRef.current.getBoundingClientRect();
        setDimensions( { width, height } );
      }
    };

    // Initial update
    updateDimensions();

    // Add resize listener
    window.addEventListener( "resize", updateDimensions );

    // Cleanup
    return () =>
    {
      window.removeEventListener( "resize", updateDimensions );
    };
  }, [] );

  // Node color accessor function
  const getNodeColor = useCallback( ( node: any ) =>
  {
    const typedNode = node as SemanticNode;
    return typedNode.color ||
      DEFAULT_GRAPH_CONFIG.nodeColorMap[ typedNode.type ] ||
      DEFAULT_GRAPH_CONFIG.defaultNodeColor;
  }, [] );

  // Node size accessor function
  const getNodeSize = useCallback( ( node: any ) =>
  {
    const typedNode = node as SemanticNode;
    const baseSize = typedNode.id === word ?
      DEFAULT_GRAPH_CONFIG.maxNodeSize * 1.5 :
      DEFAULT_GRAPH_CONFIG.minNodeSize +
      ( DEFAULT_GRAPH_CONFIG.maxNodeSize - DEFAULT_GRAPH_CONFIG.minNodeSize ) * typedNode.weight;

    // Increase size for selected node
    return selectedNode && selectedNode.id === typedNode.id ? baseSize * 1.3 : baseSize;
  }, [ selectedNode, word ] );

  // Link color accessor function
  const getLinkColor = useCallback( ( link: any ) =>
  {
    const typedLink = link as SemanticLink;
    return typedLink.color ||
      DEFAULT_GRAPH_CONFIG.linkColorMap[ typedLink.type ] ||
      DEFAULT_GRAPH_CONFIG.defaultLinkColor;
  }, [] );

  // Link width accessor function
  const getLinkWidth = useCallback( ( link: any ) =>
  {
    const typedLink = link as SemanticLink;
    return DEFAULT_GRAPH_CONFIG.minLinkWidth +
      ( DEFAULT_GRAPH_CONFIG.maxLinkWidth - DEFAULT_GRAPH_CONFIG.minLinkWidth ) * typedLink.weight;
  }, [] );

  // Node click handler
  const handleNodeClick = useCallback( ( node: any ) =>
  {
    const typedNode = node as SemanticNode;
    setSelectedNode( prevNode =>
      prevNode && prevNode.id === typedNode.id ? null : typedNode
    );

    // Center view on node
    if ( graphRef.current )
    {
      graphRef.current.centerAt( node.x, node.y, 1000 );
      graphRef.current.zoom( 2, 1000 );
    }
  }, [] );

  // Node right-click handler for navigation
  const handleNodeRightClick = useCallback( ( node: any ) =>
  {
    const typedNode = node as SemanticNode;
    // Navigate to the word's exploration page
    window.open( `/explore?word=${ encodeURIComponent( typedNode.word ) }`, '_blank' );
  }, [] );

  // Custom node canvas object
  const nodeCanvasObject = useCallback( ( node: any, ctx: CanvasRenderingContext2D, globalScale: number ) =>
  {
    const typedNode = node as SemanticNode;
    const label = typedNode.word;
    const fontSize = 16 / globalScale;
    const nodeSize = getNodeSize( node );

    // Node circle
    ctx.beginPath();
    ctx.fillStyle = getNodeColor( node );
    ctx.arc( node.x, node.y, nodeSize, 0, 2 * Math.PI );
    ctx.fill();

    // Node border (thicker for selected node)
    ctx.strokeStyle = selectedNode && selectedNode.id === typedNode.id ?
      '#ffffff' : 'rgba(255,255,255,0.5)';
    ctx.lineWidth = selectedNode && selectedNode.id === typedNode.id ?
      2 / globalScale : 1 / globalScale;
    ctx.stroke();

    // Node label
    ctx.font = `${ fontSize }px Sans-Serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';

    // Text shadow for better readability
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    ctx.fillText( label, node.x, node.y + nodeSize + fontSize );

    // Reset shadow
    ctx.shadowColor = 'transparent';
  }, [ getNodeColor, getNodeSize, selectedNode ] );

  // Render loading state
  if ( isLoading )
  {
    return (
      <div className={ `flex items-center justify-center ${ className }` } style={ { minHeight: '400px' } }>
        <div className="flex flex-col items-center gap-4">
          <div className="h-10 w-10 border-4 border-primary/30 border-t-primary rounded-full animate-spin"></div>
          <p className="text-muted-foreground">Generating semantic graph...</p>
        </div>
      </div>
    );
  }

  // Render empty state
  if ( !word )
  {
    return (
      <div className={ `flex items-center justify-center ${ className }` } style={ { minHeight: '400px' } }>
        <p className="text-muted-foreground">Enter a word to visualize its semantic relationships</p>
      </div>
    );
  }

  // Render error state
  if ( !graphData && !isLoading )
  {
    return (
      <div className={ `flex items-center justify-center ${ className }` } style={ { minHeight: '400px' } }>
        <p className="text-muted-foreground">No semantic data available for this word</p>
      </div>
    );
  }

  return (
    <div className={ `relative ${ className }` } ref={ containerRef } style={ { minHeight: '400px' } }>
      {/* Graph Visualization */ }
      { graphData && (
        <ForceGraph2D
          ref={ graphRef }
          graphData={ graphData }
          width={ dimensions.width }
          height={ dimensions.height }
          nodeColor={ getNodeColor }
          nodeVal={ getNodeSize }
          linkColor={ getLinkColor }
          linkWidth={ getLinkWidth }
          nodeCanvasObject={ nodeCanvasObject }
          onNodeClick={ handleNodeClick }
          onNodeRightClick={ handleNodeRightClick }
          linkDirectionalParticles={ 2 }
          linkDirectionalParticleWidth={ 2 }
          linkDirectionalParticleSpeed={ 0.005 }
          cooldownTime={ 3000 }
          d3AlphaDecay={ 0.02 }
          d3VelocityDecay={ 0.3 }
          nodeRelSize={ 6 }
          backgroundColor="rgba(0,0,0,0)"
        />
      ) }

      {/* Selected Node Info Panel */ }
      { selectedNode && (
        <div className="absolute bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-72 glass-effect p-4 rounded-lg">
          <h3 className="text-lg font-semibold mb-1">{ selectedNode.word }</h3>
          <div className="flex items-center gap-2 mb-2">
            <span className="bg-primary/10 text-primary text-xs px-2 py-1 rounded">
              { selectedNode.type }
            </span>
          </div>
          { selectedNode.definitions && selectedNode.definitions.length > 0 && (
            <p className="text-sm text-muted-foreground mb-2">{ selectedNode.definitions[ 0 ] }</p>
          ) }
          { selectedNode.etymology && (
            <div className="text-xs text-muted-foreground">
              <span className="font-medium">Etymology:</span> { selectedNode.etymology }
            </div>
          ) }
        </div>
      ) }
    </div>
  );
}```


ğŸŸ¦ File: src/lib/api/types/api-types.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * API Types
 * Defines shared types and interfaces for all API services
 */

// Base API response interface
export interface ApiResponse<T> {
  data?: T;
  error?: ApiError;
  status: number;
  success: boolean;
}

// Standard error interface
export interface ApiError {
  code: string;
  message: string;
  details?: unknown;
}

// Image generation types
export interface ImageGenerationRequest {
  prompt: string;
  width?: number;
  height?: number;
  enhancePrompt?: boolean;
  style?: 'realistic' | 'artistic' | 'minimalist' | 'educational';
}

export interface ImageGenerationResponse {
  url: string;
  prompt: string;
  model?: string;
  error?: ApiError;
  fallback?: boolean;
  width?: number;
  height?: number;
}

// Perplexity language API types
export interface LanguageRequest {
  query: string;
  maxTokens?: number;
  temperature?: number;
  contextItems?: string[];
}

export interface LanguageResponse {
  text: string;
  sources?: {
    title: string;
    url: string;
    snippet: string;
  }[];
  tokens: {
    total: number;
    prompt: number;
    completion: number;
  };
  model: string;
}

// Grok creative suggestions API types
export interface SuggestionRequest {
  word: string;
  count?: number;
  creativity?: number; // 0-1 scale
  includeSynonyms?: boolean;
  includeAntonyms?: boolean;
  includeRelated?: boolean;
}

export interface SuggestionResponse {
  suggestions: WordSuggestion[];
  metadata: {
    model: string;
    requestedWord: string;
    totalResults: number;
  };
}

export interface WordSuggestion {
  word: string;
  type: 'synonym' | 'antonym' | 'related' | 'rhyme' | 'creative';
  score: number;
  definition?: string;
  examples?: string[];
}

// API configuration types
export interface CircuitBreakerConfig {
  failureThreshold?: number;    // Number of failures before opening the circuit
  successThreshold?: number;    // Number of successes needed to close the circuit
  timeout?: number;             // Milliseconds to wait before testing if service has recovered
}

export interface ApiServiceConfig {
  baseUrl: string;
  apiKey?: string;
  defaultTimeout?: number;
  defaultHeaders?: Record<string, string>;
  circuitBreaker?: CircuitBreakerConfig;
  retryCount?: number;
}

// Cache configuration types
export interface CacheConfig {
  staleTime: number; // milliseconds
  cacheTime: number; // milliseconds
  retry: number;
}```


ğŸŸ¦ File: src/hooks/use-word-suggestions.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
'use client';

import { useCallback } from 'react';
import { SWRConfiguration } from 'swr';
import { useApi } from './use-api';
import { grokService } from '@/lib/api';
import { SuggestionRequest, SuggestionResponse } from '@/lib/api/types/api-types';
import { LANGUAGE_SWR_CONFIG } from '@/lib/swr-config';

/**
 * Hook for word suggestions using Grok API
 * Provides a cached, optimized interface to the Grok service
 */
export function useWordSuggestions(
  word: string | null,
  options?: Partial<SuggestionRequest>,
  config?: SWRConfiguration
) {
  // Only create a key if we have a word
  const key = word ? `word-suggestions-${word}-${JSON.stringify(options)}` : null;

  // Use our custom API hook with the Grok service
  const api = useApi<SuggestionResponse>(
    key,
    async () => {
      if (!word) {
        throw new Error('No word provided for suggestions');
      }

      // Prepare the request with defaults and overrides
      const request: SuggestionRequest = {
        word,
        count: 10,
        creativity: 0.7,
        includeSynonyms: true,
        includeAntonyms: true,
        includeRelated: true,
        ...options,
      };

      // Call the Grok service
      return grokService.getSuggestions(request);
    },
    {
      ...LANGUAGE_SWR_CONFIG,
      ...config,
    }
  );

  // Convenience method to get suggestions by type
  const getSuggestionsByType = useCallback((type: string) => {
    if (!api.data?.suggestions) return [];
    return api.data.suggestions.filter(s => s.type === type);
  }, [api.data]);

  // Convenience methods for specific types
  const synonyms = getSuggestionsByType('synonym');
  const antonyms = getSuggestionsByType('antonym');
  const related = getSuggestionsByType('related');
  const creative = getSuggestionsByType('creative');

  // Check if API key is available
  const isApiKeyMissing = api.error?.code === 'GROK_AUTH_ERROR';

  // For dev/demo: fall back to mock data if API key is missing
  if (isApiKeyMissing && process.env.NODE_ENV === 'development' && word) {
    return {
      ...api,
      data: grokService.getMockSuggestions(word),
      isApiKeyMissing,
      synonyms: [], // Add mock data by type
      antonyms: [],
      related: [],
      creative: [],
    };
  }

  return {
    ...api,
    isApiKeyMissing,
    getSuggestionsByType,
    synonyms,
    antonyms,
    related,
    creative,
  };
}```


ğŸŸ¦ File: src/hooks/use-language-context.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
'use client';

import { SWRConfiguration } from 'swr';
import { useApi } from './use-api';
import { perplexityService } from '@/lib/api';
import { LanguageRequest, LanguageResponse } from '@/lib/api/types/api-types';
import { LANGUAGE_SWR_CONFIG } from '@/lib/swr-config';

/**
 * Hook for contextual language queries using Perplexity API
 * Provides a cached interface to the Perplexity service
 */
export function useLanguageContext(
  query: string | null,
  options?: Partial<LanguageRequest>,
  config?: SWRConfiguration
) {
  // Only create a key if we have a query
  const key = query ? `language-context-${query}-${JSON.stringify(options)}` : null;

  // Use our custom API hook with the Perplexity service
  const api = useApi<LanguageResponse>(
    key,
    async () => {
      if (!query) {
        throw new Error('No query provided for language context');
      }

      // Prepare the request with defaults and overrides
      const request: LanguageRequest = {
        query,
        maxTokens: 300,
        temperature: 0.7,
        contextItems: [],
        ...options,
      };

      // Call the Perplexity service
      return perplexityService.query(request);
    },
    {
      ...LANGUAGE_SWR_CONFIG,
      ...config,
    }
  );

  // Extract token usage for monitoring/display
  const tokenUsage = api.data?.tokens;

  // Check if API key is available
  const isApiKeyMissing = api.error?.code === 'PERPLEXITY_AUTH_ERROR';

  // For dev/demo: fall back to mock data if API key is missing
  if (isApiKeyMissing && process.env.NODE_ENV === 'development' && query) {
    return {
      ...api,
      data: {
        text: `This is mock language data for the query: "${query}"`,
        model: 'mock-model',
        tokens: {
          total: 0,
          prompt: 0,
          completion: 0,
        },
      },
      isApiKeyMissing,
      tokenUsage: null,
    };
  }

  return {
    ...api,
    isApiKeyMissing,
    tokenUsage,
  };
}```


ğŸŸ¦ File: src/hooks/use-image-generation.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
"use client";

import { useState, useCallback } from 'react';
import { SWRConfiguration } from 'swr';
import { useApi } from './use-api';
import { fluxService } from '@/lib/api';
import { ImageGenerationRequest, ImageGenerationResponse } from '@/lib/api/types/api-types';
import { IMAGE_SWR_CONFIG } from '@/lib/swr-config';

/**
 * Enhanced hook for generating images using our API service layer
 * Provides a cached, optimized interface to the Flux service
 */
export function useImageGeneration(
  word: string | null,
  options?: Partial<ImageGenerationRequest>,
  config?: SWRConfiguration
) {
  // Only trigger the fetch when explicitly requested
  const [shouldFetch, setShouldFetch] = useState(false);

  // Create cache key with word and options for proper caching
  const key = shouldFetch && word
    ? `image-gen-${word}-${JSON.stringify(options)}`
    : null;

  // Use our API hook with the Flux service
  const api = useApi<ImageGenerationResponse>(
    key,
    async () => {
      if (!word) {
        throw new Error('No word provided for image generation');
      }

      // Prepare the request with defaults and overrides
      const request: ImageGenerationRequest = {
        prompt: word,
        width: 512,
        height: 512,
        enhancePrompt: true,
        style: 'minimalist',
        ...options,
      };

      // Call the Flux service
      return fluxService.generateImage(request);
    },
    {
      ...IMAGE_SWR_CONFIG,
      ...config,
      // Override revalidation for image generation to be conservative
      revalidateOnFocus: false,
      dedupingInterval: 3600000, // 1 hour
    }
  );

  // Function to trigger image generation
  const generateImage = useCallback(() => {
    setShouldFetch(true);
  }, []);

  // Function to reset and try again
  const reset = useCallback(() => {
    api.refresh();
  }, [api]);

  // Check if using fallback
  const isFallback = api.data?.fallback === true;

  return {
    ...api,
    generateImage,
    reset,
    isFallback,
  };
}```


ğŸŸ¦ File: src/hooks/use-claude-analysis.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
'use client';

import { SWRConfiguration } from 'swr';
import { useApi } from './use-api';
import { anthropicService } from '@/lib/api';
import { LANGUAGE_SWR_CONFIG } from '@/lib/swr-config';

/**
 * Type for the linguistic analysis response
 */
interface LinguisticAnalysis {
  etymology: {
    origin: string;
    history: string;
    derivation?: string;
  };
  semantics: {
    meaning: string;
    nuances: string[];
    domains?: string[];
  };
  usage: {
    common_phrases: string[];
    collocations: string[];
    examples: string[];
  };
  related: {
    synonyms: string[];
    antonyms: string[];
    conceptual: string[];
  };
  register: {
    formality: string;
    connotation: string;
    contexts: string[];
  };
  model: string;
  tokens: {
    total: number;
    prompt: number;
    completion: number;
  };
}

/**
 * Custom hook for advanced linguistic analysis using Claude
 * This hook caches results and provides a clean interface to the Anthropic service
 */
export function useClaudeAnalysis(
  word: string | null,
  config?: SWRConfiguration
) {
  // Only create a key if we have a word
  const key = word ? `claude-analysis-${word}` : null;

  // Use our API hook with the Anthropic service
  const api = useApi<LinguisticAnalysis>(
    key,
    async () => {
      if (!word) {
        throw new Error('No word provided for linguistic analysis');
      }

      // Create a detailed prompt for linguistic analysis
      const prompt = `Analyze the word "${word}" in depth, considering its etymology, semantics, usage patterns, and related concepts.`;

      // Call the Anthropic service
      return anthropicService.analyzeLanguage(prompt);
    },
    {
      ...LANGUAGE_SWR_CONFIG,
      ...config,
      // Increase dedupingInterval since linguistic analyses don't change often
      dedupingInterval: 3600000, // 1 hour
    }
  );

  // Check if API key is missing
  const isApiKeyMissing = api.error?.code === 'ANTHROPIC_AUTH_ERROR';

  // For dev/demo: fall back to mock data if API key is missing
  if (isApiKeyMissing && process.env.NODE_ENV === 'development' && word) {
    return {
      ...api,
      data: getMockAnalysis(word),
      isApiKeyMissing,
    };
  }

  return {
    ...api,
    isApiKeyMissing,
  };
}

/**
 * Generate mock linguistic analysis for development and testing
 */
function getMockAnalysis(word: string): LinguisticAnalysis {
  return {
    etymology: {
      origin: "Mock Latin origin",
      history: `Mock historical development of the word "${word}"`,
      derivation: "Mock word derivation",
    },
    semantics: {
      meaning: `Primary meaning of "${word}"`,
      nuances: ["Mock nuance 1", "Mock nuance 2", "Mock nuance 3"],
      domains: ["General", "Academic"],
    },
    usage: {
      common_phrases: [`${word} and related term`, `Another common use of ${word}`],
      collocations: [`adjective ${word}`, `${word} noun`],
      examples: [
        `Here is an example sentence using "${word}".`,
        `Another example of "${word}" in context.`,
      ],
    },
    related: {
      synonyms: ["mock-synonym-1", "mock-synonym-2"],
      antonyms: ["mock-antonym-1", "mock-antonym-2"],
      conceptual: ["mock-related-1", "mock-related-2"],
    },
    register: {
      formality: "Neutral to formal",
      connotation: "Neutral",
      contexts: ["Academic", "Literary", "Everyday"],
    },
    model: "mock-claude-model",
    tokens: {
      total: 0,
      prompt: 0,
      completion: 0,
    },
  };
}```


ğŸŸ¦ File: src/hooks/use-api.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
'use client';

import { useState, useCallback } from 'react';
import useSWR, { SWRConfiguration } from 'swr';
import { SWR_CONFIG } from '@/lib/swr-config';
import { ApiResponse } from '@/lib/api/types/api-types';

/**
 * Type for the fetcherFn to ensure it returns a Promise with ApiResponse<T>
 * Using unknown instead of any for better type safety
 */
type ApiFetcherFn<T> = (...args: unknown[]) => Promise<ApiResponse<T>>;

/**
 * Type for direct data updates
 */
interface MutateOptions<T> {
  data?: T;
  error?: Error;
  revalidate?: boolean;
}

/**
 * Custom hook for API calls using SWR
 * Provides consistent error handling, loading states, and caching
 *
 * @template T - Type of data returned by the API
 * @param key - The SWR cache key (or null to disable fetching)
 * @param fetcherFn - Function that returns API data
 * @param config - SWR configuration overrides
 */
export function useApi<T = unknown>(
  key: string | null,
  fetcherFn: ApiFetcherFn<T>,
  config?: SWRConfiguration
) {
  // Track if the operation is in manual update process (e.g. during form submission)
  const [isManualSubmitting, setIsManualSubmitting] = useState(false);

  // Use SWR for data fetching with configuration
  const {
    data: apiResponse,
    error: swrError,
    isLoading: swrLoading,
    isValidating,
    mutate,
  } = useSWR<ApiResponse<T>>(
    key,
    fetcherFn,
    {
      ...SWR_CONFIG, // Global defaults
      ...config,     // Component-specific overrides
    }
  );

  // Extract API data and errors
  const data = apiResponse?.data;
  const error = swrError || apiResponse?.error;

  // Create a clean isLoading state that includes both SWR loading and manual submitting
  const isLoading = swrLoading || isManualSubmitting;

  // Helper for manual mutations with loading state
  const updateData = useCallback(
    async (fn: () => Promise<ApiResponse<T>>, options?: MutateOptions<T>) => {
      try {
        setIsManualSubmitting(true);

        // If optimistic update data provided, update immediately
        if (options?.data || options?.error) {
          await mutate({
            data: options.data,
            error: options.error,
            status: options.error ? 400 : 200,
            success: !options.error,
          } as ApiResponse<T>, { revalidate: false });
        }

        // Call the update function
        const result = await fn();

        // Log for debugging
        console.log(`ğŸ“ [API] Update result:`, {
          success: result.success,
          status: result.status,
          hasData: !!result.data,
          hasError: !!result.error
        });

        // Update the cache with the result
        await mutate(result, { revalidate: options?.revalidate ?? false });

        return result;
      } catch (err) {
        // Log the error
        console.error('[API] Unhandled error in updateData:', err);

        // Create an error response
        const errorResponse: ApiResponse<T> = {
          data: undefined,
          error: {
            code: 'UNHANDLED_ERROR',
            message: err instanceof Error ? err.message : String(err),
          },
          status: 500,
          success: false,
        };

        // Update the cache with the error
        await mutate(errorResponse, { revalidate: false });

        return errorResponse;
      } finally {
        setIsManualSubmitting(false);
      }
    },
    [mutate]
  );

  // Create a function to reset the cache and force a fresh fetch
  const refresh = useCallback(() => {
    console.log(`ğŸ”„ [API] Refreshing data for key: ${key}`);
    return mutate(undefined, { revalidate: true });
  }, [mutate, key]);

  return {
    data,
    error,
    apiResponse,
    isLoading,
    isValidating,
    isSubmitting: isManualSubmitting,
    mutate,
    updateData,
    refresh,
  };
}

/**
 * Specialized hook for image generation
 * Manages the state for triggering image generation requests
 */
export function useImageGeneration(
  word: string | null,
  config?: SWRConfiguration
) {
  const [generateImage, setGenerateImage] = useState<boolean>(false);

  // Only fetch if explicitly triggered
  const key = generateImage && word ? `image-gen-${word}` : null;

  const api = useApi<{url: string; prompt: string; model: string}>(
    key,
    async () => {
      if (!word) {
        return {
          data: undefined,
          status: 400,
          success: false,
          error: { code: 'MISSING_WORD', message: 'No word provided for image generation' }
        };
      }

      console.log(`ğŸ¨ [API] Generating image for word: ${word}`);

      try {
        const response = await fetch('/api/generate-image', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ prompt: word }),
        });

        const data = await response.json();

        return {
          data,
          status: response.status,
          success: response.ok,
          error: !response.ok ?
            { code: 'API_ERROR', message: data.message || 'Failed to generate image' } :
            undefined,
        };
      } catch (error) {
        console.error('ğŸ”¥ [API] Image generation error:', error);
        return {
          data: undefined,
          status: 500,
          success: false,
          error: {
            code: 'FETCH_ERROR',
            message: error instanceof Error ? error.message : 'Failed to contact image generation service'
          }
        };
      }
    },
    config
  );

  const generate = useCallback(() => {
    console.log(`ğŸš€ [API] Triggering image generation for: ${word}`);
    setGenerateImage(true);
  }, [word]);

  return {
    ...api,
    generate,
  };
}```


ğŸŸ¦ File: src/lib/waitlist-storage.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Waitlist Storage using Vercel KV
 *
 * This module provides functions to store waitlist emails in Vercel KV.
 * For local development, it falls back to console logging.
 */

import { kv } from '@vercel/kv';

/**
 * Interface for waitlist entries
 */
export interface WaitlistEntry {
  email: string;
  timestamp: string;
  source: string;
}

/**
 * Adds an email to the waitlist
 *
 * In development mode, this logs the entry to the console
 * In production, this uses Vercel KV to store entries
 *
 * @param email The email to add
 * @param metadata Additional metadata about the submission
 * @returns Promise that resolves to true if successful
 */
export async function addToWaitlist(
  email: string,
  metadata: { timestamp: string; source: string }
): Promise<boolean> {
  try {
    // Create the entry object
    const entry: WaitlistEntry = {
      email,
      timestamp: metadata.timestamp,
      source: metadata.source
    };

    // In development, just log the entry
    if (process.env.NODE_ENV !== 'production') {
      console.log('ğŸ“ [Waitlist] Adding entry in development mode:', entry);
      // Simulate a delay to mimic storage operation
      await new Promise(resolve => setTimeout(resolve, 500));
      return true;
    }

    // In production, use Vercel KV
    const key = `waitlist:${Date.now()}:${email}`;

    // Use a transaction to ensure atomicity
    const transaction = kv.multi();
    // Store the full entry with 30-day expiration
    transaction.set(key, entry, { ex: 60 * 60 * 24 * 30 });
    // Add email to a set for quick lookup
    transaction.sadd('waitlist:emails', email);

    // Execute the transaction
    const results = await transaction.exec();

    // Log success for monitoring
    console.log(`âœ… [Waitlist] Added email: ${email}`);

    // Check if all transaction commands succeeded
    return results.every(result => result === 'OK' || result === 1);
  } catch (error) {
    // Log detailed error but avoid exposing internals in production
    console.error('âŒ [Waitlist] Storage error:', error);
    throw new Error('Failed to store waitlist entry');
  }
}

/**
 * Checks if an email is already on the waitlist
 *
 * @param email The email to check
 * @returns Promise that resolves to true if the email exists
 */
export async function checkWaitlistEmail(email: string): Promise<boolean> {
  try {
    // In development, always return false for testing
    if (process.env.NODE_ENV !== 'production') {
      console.log(`ğŸ” [Waitlist] Checking email in development mode: ${email}`);
      return false;
    }

    // In production, check against Vercel KV
    const exists = await kv.sismember('waitlist:emails', email);
    return exists === 1;
  } catch (error) {
    // Log error but fail open (assume email doesn't exist)
    console.error('âŒ [Waitlist] Check error:', error);
    return false;
  }
}

/**
 * Retrieves all waitlist entries
 * This is useful for admin dashboards or data exports
 *
 * @returns Promise that resolves to an array of waitlist entries
 */
export async function getWaitlistEntries(): Promise<WaitlistEntry[]> {
  try {
    // In development, return empty array
    if (process.env.NODE_ENV !== 'production') {
      console.log('ğŸ” [Waitlist] Getting entries in development mode');
      return [];
    }

    // In production, query Vercel KV
    // Get all emails from the set
    const emails = await kv.smembers('waitlist:emails');
    const entries: WaitlistEntry[] = [];

    // For each email, find the corresponding entry
    for (const email of emails) {
      // Find keys matching this email
      const keys = await kv.keys(`waitlist:*:${email}`);
      if (keys.length > 0) {
        // Get the first entry (most recent if multiple)
        const entry = await kv.get<WaitlistEntry>(keys[0]);
        if (entry) entries.push(entry);
      }
    }

    return entries;
  } catch (error) {
    // Log error but return empty array to fail gracefully
    console.error('âŒ [Waitlist] Fetch error:', error);
    return [];
  }
}

/**
 * Removes an email from the waitlist
 * Useful for unsubscribe functionality
 *
 * @param email The email to remove
 * @returns Promise that resolves to true if successful
 */
export async function removeFromWaitlist(email: string): Promise<boolean> {
  try {
    // In development, just log
    if (process.env.NODE_ENV !== 'production') {
      console.log(`ğŸ—‘ï¸ [Waitlist] Removing email in development mode: ${email}`);
      return true;
    }

    // In production, use Vercel KV
    // Find all keys for this email
    const keys = await kv.keys(`waitlist:*:${email}`);

    // Use transaction to ensure atomicity
    const transaction = kv.multi();
    // Remove email from set
    transaction.srem('waitlist:emails', email);
    // Remove all entries for this email
    for (const key of keys) {
      transaction.del(key);
    }

    // Execute transaction
    await transaction.exec();
    console.log(`âœ… [Waitlist] Removed email: ${email}`);

    return true;
  } catch (error) {
    console.error('âŒ [Waitlist] Removal error:', error);
    return false;
  }
}```


ğŸŸ¦ File: src/lib/semantic-graph/generate-graph.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
import { SemanticGraph, SemanticNode, SemanticLink } from "@/types/semantic-graph";

/**
 * Generates a semantic graph from word data
 *
 * This function takes word data from the API and transforms it into
 * a graph structure that can be visualized.
 *
 * @param wordData - The word data from the API
 * @returns A semantic graph structure
 */
export function generateSemanticGraph ( wordData: any ): SemanticGraph
{
  if ( !wordData )
  {
    console.error( "Cannot generate semantic graph: No word data provided" );
    return { nodes: [], links: [] };
  }

  console.log( "Generating semantic graph for:", wordData.word );

  // Create the primary node for the main word
  const primaryNode: SemanticNode = {
    id: wordData.word,
    word: wordData.word,
    type: 'primary',
    weight: 1,
    definitions: [ wordData.coreMeaning ],
    etymology: wordData.etymology,
  };

  const nodes: SemanticNode[] = [ primaryNode ];
  const links: SemanticLink[] = [];

  // Process related words
  if ( wordData.relatedWords && Array.isArray( wordData.relatedWords ) )
  {
    wordData.relatedWords.forEach( ( related: any, index: number ) =>
    {
      // Skip if no word
      if ( !related.word ) return;

      // Determine node type based on the relationship
      let nodeType: SemanticNode[ 'type' ] = 'related';
      let linkType: SemanticLink[ 'type' ] = 'related';

      // Map relationship types
      if ( related.type?.toLowerCase().includes( 'synonym' ) )
      {
        nodeType = 'synonym';
        linkType = 'synonym';
      } else if ( related.type?.toLowerCase().includes( 'antonym' ) )
      {
        nodeType = 'antonym';
        linkType = 'antonym';
      } else if ( related.type?.toLowerCase().includes( 'root' ) ||
        related.type?.toLowerCase().includes( 'etymology' ) )
      {
        nodeType = 'root';
        linkType = 'derivation';
      }

      // Create node for the related word
      const node: SemanticNode = {
        id: related.word,
        word: related.word,
        type: nodeType,
        // Weight decreases with index to show importance
        weight: Math.max( 0.3, 1 - ( index * 0.1 ) ),
        definitions: related.meaning ? [ related.meaning ] : undefined,
      };

      // Create link between primary word and related word
      const link: SemanticLink = {
        source: primaryNode.id,
        target: node.id,
        type: linkType,
        // Weight matches node weight
        weight: node.weight,
      };

      nodes.push( node );
      links.push( link );
    } );
  }

  // Add connections between related words based on similarity
  // This creates a more interesting graph structure
  for ( let i = 1; i < nodes.length; i++ )
  {
    for ( let j = i + 1; j < nodes.length; j++ )
    {
      // Only connect nodes of the same type with some probability
      if ( nodes[ i ].type === nodes[ j ].type && Math.random() > 0.7 )
      {
        links.push( {
          source: nodes[ i ].id,
          target: nodes[ j ].id,
          type: nodes[ i ].type as SemanticLink[ 'type' ],
          weight: 0.3, // Weaker connections between related words
        } );
      }
    }
  }

  console.log( `Generated semantic graph with ${ nodes.length } nodes and ${ links.length } links` );

  return {
    nodes,
    links,
  };
}

/**
 * Enriches a semantic graph with additional data
 *
 * This function would typically call an AI service to enhance
 * the graph with additional relationships and information.
 * Currently returns the original graph as a placeholder.
 *
 * @param graph - The semantic graph to enrich
 * @returns The enriched semantic graph
 */
export async function enrichSemanticGraph ( graph: SemanticGraph ): Promise<SemanticGraph>
{
  // This is a placeholder for future AI-based graph enrichment
  // In a real implementation, this would call Perplexity or another AI service
  // to add more nodes and links based on deeper semantic analysis

  console.log( "Enriching semantic graph (placeholder)" );

  return graph;
}```


ğŸŸ¦ File: src/lib/google-sheets.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Google Sheets integration for waitlist functionality (DEPRECATED)
 *
 * This was a simplified testing implementation that appended email addresses
 * to a publicly editable Google Sheet.
 *
 * DEPRECATED: This has been replaced by the waitlist-storage.ts module.
 */

/**
 * DEPRECATED: Use waitlist-storage.ts instead.
 * This function is kept for reference purposes only.
 */
export async function addToWaitlist(
  email: string,
  metadata: { timestamp: string; source: string }
): Promise<boolean> {
  console.warn('âš ï¸ google-sheets.ts is deprecated. Use waitlist-storage.ts instead.');
  console.log('[DEPRECATED] Would add to waitlist:', { email, metadata });
  return true;
}

/**
 * DEPRECATED: USE THE WAITLIST-STORAGE.TS MODULE INSTEAD
 *
 * This file contains the original integration with Google Sheets
 * and is maintained for reference only. All new code should use
 * the waitlist-storage.ts module which supports multiple storage backends.
 */

/*
// Example Google Apps Script implementation for reference:

export async function addToWaitlistForReal(
  email: string,
  metadata: { timestamp: string; source: string }
): Promise<boolean> {
  try {
    // Google Apps Script web app URL
    const WEBAPP_URL = 'https://script.google.com/macros/s/your-script-id/exec';

    const response = await axios.post(WEBAPP_URL, {
      email,
      timestamp: metadata.timestamp,
      source: metadata.source
    });

    if (response.status !== 200) {
      throw new Error(`Failed to add to waitlist: ${response.statusText}`);
    }

    return true;
  } catch (error) {
    console.error('Error adding to waitlist:', error);
    throw error;
  }
}
*/

// For a production implementation, consider using a third-party service
// that abstracts away the complexity of Google Sheets API authentication
// Examples: Sheet.best, SheetDB, Retool, or a custom Google Apps Script```


ğŸŸ¦ File: src/lib/error-handling/circuit-breaker.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Circuit Breaker Pattern Implementation
 *
 * Protects services from repeated failures by temporarily disabling calls
 * to problematic dependencies. Implements the circuit breaker pattern with
 * three states: CLOSED (normal operation), OPEN (failing, no calls allowed),
 * and HALF-OPEN (testing if service has recovered).
 *
 * Usage:
 * ```
 * const breaker = new CircuitBreaker({
 *   failureThreshold: 3,
 *   successThreshold: 2,
 *   timeout: 30000
 * });
 *
 * try {
 *   const result = await breaker.execute(() => apiCall());
 *   // Handle success
 * } catch (error) {
 *   // Handle error or fallback
 * }
 * ```
 */

export type CircuitBreakerState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';

export interface CircuitBreakerOptions
{
  failureThreshold: number;    // Number of failures before opening the circuit
  successThreshold: number;    // Number of successes needed to close the circuit
  timeout: number;             // Milliseconds to wait before attempting to recover
  monitorIntervalMs?: number;  // Interval for emitting circuit state changes
  onStateChange?: ( from: CircuitBreakerState, to: CircuitBreakerState ) => void;
}

export class CircuitBreaker
{
  private state: CircuitBreakerState = 'CLOSED';
  private failureCount = 0;
  private successCount = 0;
  private nextAttempt = 0;
  private lastError: Error | null = null;
  private readonly options: CircuitBreakerOptions;

  constructor ( options: CircuitBreakerOptions )
  {
    this.options = {
      ...options,
      monitorIntervalMs: options.monitorIntervalMs || 5000,
    };

    // Log initial state for observability
    console.log( `ğŸ”Œ Circuit Breaker initialized in ${ this.state } state` );
  }

  /**
   * Execute a function with circuit breaker protection
   * @param fn Function to execute
   * @returns Promise with the result of fn
   * @throws Error if circuit is open or if fn throws
   */
  async execute<T> ( fn: () => Promise<T> ): Promise<T>
  {
    if ( this.state === 'OPEN' )
    {
      // Check if timeout has elapsed
      if ( Date.now() > this.nextAttempt )
      {
        this.toHalfOpen();
      } else
      {
        // Return the last error or a circuit open error
        const lastErrorMessage = this.lastError ? `: ${ this.lastError.message }` : '';
        throw new Error( `Service unavailable - Circuit Breaker Open${ lastErrorMessage }` );
      }
    }

    try
    {
      // Execute the function
      const result = await fn();

      // Handle success based on current state
      this.onSuccess();

      return result;
    } catch ( error )
    {
      // Track failure and potentially open the circuit
      this.onFailure( error instanceof Error ? error : new Error( String( error ) ) );
      throw error;
    }
  }

  /**
   * Get the current state of the circuit breaker
   */
  getState (): CircuitBreakerState
  {
    return this.state;
  }

  /**
   * Get detailed status of the circuit breaker
   */
  getStatus ():
    {
      state: CircuitBreakerState;
      failureCount: number;
      successCount: number;
      nextAttempt: number;
      remainingTimeMs: number;
    }
  {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      nextAttempt: this.nextAttempt,
      remainingTimeMs: Math.max( 0, this.nextAttempt - Date.now() )
    };
  }

  /**
   * Manually reset the circuit breaker to closed state
   */
  reset (): void
  {
    this.changeState( 'CLOSED' );
    this.failureCount = 0;
    this.successCount = 0;
    this.nextAttempt = 0;
  }

  /**
   * Handle successful execution
   */
  private onSuccess (): void
  {
    if ( this.state === 'HALF_OPEN' )
    {
      this.successCount++;

      if ( this.successCount >= this.options.successThreshold )
      {
        // Service has recovered
        this.reset();
      }
    } else if ( this.state === 'CLOSED' )
    {
      // In closed state, just reset failure count
      this.failureCount = 0;
    }
  }

  /**
   * Handle failed execution
   */
  private onFailure ( error: Error ): void
  {
    this.lastError = error;

    if ( this.state === 'HALF_OPEN' )
    {
      // If we're testing the waters and still failing,
      // open the circuit immediately
      this.toOpen();
    } else if ( this.state === 'CLOSED' )
    {
      this.failureCount++;

      if ( this.failureCount >= this.options.failureThreshold )
      {
        this.toOpen();
      }
    }
  }

  /**
   * Transition to OPEN state
   */
  private toOpen (): void
  {
    this.changeState( 'OPEN' );
    this.nextAttempt = Date.now() + this.options.timeout;
    this.successCount = 0;
  }

  /**
   * Transition to HALF_OPEN state
   */
  private toHalfOpen (): void
  {
    this.changeState( 'HALF_OPEN' );
    this.successCount = 0;
  }

  /**
   * Change state with logging and event emission
   */
  private changeState ( to: CircuitBreakerState ): void
  {
    if ( this.state === to ) return;

    const from = this.state;
    this.state = to;

    // Log state change for observability
    console.log( `ğŸ”Œ Circuit Breaker state change: ${ from } -> ${ to }` );

    // Emit state change event if callback provided
    if ( this.options.onStateChange )
    {
      this.options.onStateChange( from, to );
    }
  }
}```


ğŸŸ¦ File: src/lib/api/perplexity-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Perplexity Language Service
 * Handles contextual language understanding with Perplexity AI
 */
import { ApiService } from './api-service';
import {
  ApiResponse,
  LanguageRequest,
  LanguageResponse
} from './types/api-types';
import { AI_CONFIG } from '@/lib/ai-config';

export class PerplexityService extends ApiService {
  private defaultModel: string;

  constructor() {
    const { apiUrl, apiKey, defaultModel } = AI_CONFIG.perplexity;

    super('PerplexityService', {
      baseUrl: apiUrl || 'https://api.perplexity.ai',
      apiKey,
      defaultTimeout: 20000,
    });

    this.defaultModel = defaultModel || 'sonar-small-online';
  }

  /**
   * Query the Perplexity API for contextual language understanding
   */
  public async query(request: LanguageRequest): Promise<ApiResponse<LanguageResponse>> {
    // Check if API key is available
    if (!this.config.apiKey) {
      console.warn('âš ï¸ No Perplexity API key found.');
      return {
        error: {
          code: 'PERPLEXITY_AUTH_ERROR',
          message: 'No API key provided for Perplexity AI',
        },
        status: 401,
        success: false,
      };
    }

    try {
      const response = await this.post<LanguageResponse>('/api/query', {
        query: request.query,
        model: this.defaultModel,
        max_tokens: request.maxTokens || 500,
        temperature: request.temperature || 0.7,
        context_items: request.contextItems || [],
      });

      // Enhanced logging for development
      if (process.env.NODE_ENV === 'development' && response.data) {
        console.log(`ğŸ“š Perplexity response for query "${request.query.substring(0, 30)}...":`, {
          tokens: response.data.tokens,
          model: response.data.model,
          sourceCount: response.data.sources?.length || 0,
        });
      }

      return response;
    } catch (error) {
      console.error('âŒ Error in PerplexityService.query:', error);

      return {
        error: this.handleError(error),
        status: 500,
        success: false,
      };
    }
  }

  /**
   * Get sources for citations from a previous query
   */
  public async getSources(queryId: string): Promise<ApiResponse<any>> {
    if (!this.config.apiKey) {
      return {
        error: {
          code: 'PERPLEXITY_AUTH_ERROR',
          message: 'No API key provided for Perplexity AI',
        },
        status: 401,
        success: false,
      };
    }

    return this.get<any>(`/api/sources/${queryId}`);
  }
}

// Create and export a singleton instance
export const perplexityService = new PerplexityService();```


ğŸŸ¦ File: src/lib/api/grok-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Grok Creative Suggestions Service
 * Handles AI-powered creative word suggestions and relationships
 */
import { ApiService } from './api-service';
import {
  ApiResponse,
  SuggestionRequest,
  SuggestionResponse,
  WordSuggestion
} from './types/api-types';
import { AI_CONFIG } from '@/lib/ai-config';

export class GrokService extends ApiService {
  private defaultModel: string;

  constructor() {
    const { apiUrl, apiKey, defaultModel } = AI_CONFIG.grok;

    super('GrokService', {
      baseUrl: apiUrl || 'https://api.grok.ai',
      apiKey,
      defaultTimeout: 15000,
    });

    this.defaultModel = defaultModel || 'grok-1';
  }

  /**
   * Get creative word suggestions based on input word
   */
  public async getSuggestions(request: SuggestionRequest): Promise<ApiResponse<SuggestionResponse>> {
    // Check if API key is available
    if (!this.config.apiKey) {
      console.warn('âš ï¸ No Grok API key found.');
      return {
        error: {
          code: 'GROK_AUTH_ERROR',
          message: 'No API key provided for Grok AI',
        },
        status: 401,
        success: false,
      };
    }

    try {
      // Format the request
      const requestData = {
        word: request.word,
        count: request.count || 10,
        creativity: request.creativity || 0.7,
        include_synonyms: request.includeSynonyms !== false,
        include_antonyms: request.includeAntonyms !== false,
        include_related: request.includeRelated !== false,
        model: this.defaultModel,
      };

      // Call Grok API
      const response = await this.post<SuggestionResponse>('/api/suggestions', requestData);

      // Enhanced logging for development
      if (process.env.NODE_ENV === 'development' && response.data) {
        console.log(`ğŸ”® Grok suggestion response for word "${request.word}":`, {
          suggestionCount: response.data.suggestions?.length || 0,
          model: response.data.metadata?.model,
        });
      }

      return response;
    } catch (error) {
      console.error('âŒ Error in GrokService.getSuggestions:', error);

      return {
        error: this.handleError(error),
        status: 500,
        success: false,
      };
    }
  }

  /**
   * Get in-depth information about a specific word
   */
  public async getWordInfo(word: string): Promise<ApiResponse<any>> {
    if (!this.config.apiKey) {
      return {
        error: {
          code: 'GROK_AUTH_ERROR',
          message: 'No API key provided for Grok AI',
        },
        status: 401,
        success: false,
      };
    }

    return this.get<any>(`/api/wordinfo/${encodeURIComponent(word)}`);
  }

  /**
   * Generate mock suggestions when API is unavailable (for development and testing)
   */
  public getMockSuggestions(word: string): SuggestionResponse {
    const mockTypes: Array<WordSuggestion['type']> = ['synonym', 'antonym', 'related', 'rhyme', 'creative'];

    // Generate 10 mock suggestions
    const suggestions: WordSuggestion[] = Array.from({ length: 10 }, (_, i) => {
      const type = mockTypes[Math.floor(Math.random() * mockTypes.length)];
      return {
        word: `${word}-${type}-${i + 1}`,
        type,
        score: Math.random(),
        definition: `This is a mock definition for ${word}-${i + 1}`,
        examples: [`Example usage of ${word}-${i + 1}`],
      };
    });

    return {
      suggestions,
      metadata: {
        model: 'mock-model',
        requestedWord: word,
        totalResults: suggestions.length,
      },
    };
  }
}

// Create and export a singleton instance
export const grokService = new GrokService();```


ğŸŸ¦ File: src/lib/api/flux-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Flux Image Generation Service
 * Handles image generation via Replicate's Flux model with consistent error handling and fallbacks
 */
import { ApiService } from './api-service';
import {
  ApiResponse,
  ImageGenerationRequest,
  ImageGenerationResponse
} from './types/api-types';
import { AI_CONFIG } from '@/lib/ai-config';

export class FluxService extends ApiService {
  private fallbackEnabled: boolean;
  private fallbackImages: string[];
  private placeholderUrl: string;
  private fluxModel: string;

  constructor() {
    // Configure from our AI configuration
    const { apiToken, fluxModel, fallback } = AI_CONFIG.replicate;
    // Use a default API URL for Replicate
    const baseUrl = 'https://api.replicate.com';

    super('FluxService', {
      baseUrl,
      apiKey: apiToken,
      defaultTimeout: 30000, // Image generation takes longer
    });

    this.fluxModel = fluxModel || 'black-forest-labs/flux-1.1-pro';
    this.fallbackEnabled = fallback.enabled;
    this.fallbackImages = fallback.localImages;
    this.placeholderUrl = fallback.placeholderUrl;
  }

  /**
   * Generate an image from a text prompt
   */
  public async generateImage(request: ImageGenerationRequest): Promise<ApiResponse<ImageGenerationResponse>> {
    // Check if API token is available
    if (!this.config.apiKey) {
      console.warn('âš ï¸ No Replicate API token found. Using fallback image.');
      return this.createFallbackResponse(request.prompt, 'No API token configured');
    }

    try {
      // Enhance prompt if needed
      const prompt = request.enhancePrompt !== false
        ? this.enhancePrompt(request.prompt, request.style || 'minimalist')
        : request.prompt;

      // For direct Replicate API access, we'd use their SDK
      // But for consistent error handling, we'll use our API layer to call the server-side endpoint
      const response = await this.post<ImageGenerationResponse>('/api/generate-image', {
        prompt,
        width: request.width || 512,
        height: request.height || 512,
        style: request.style,
      });

      // If there was an error from the API but we have fallbacks, use them
      if (!response.success && this.fallbackEnabled) {
        return this.createFallbackResponse(
          request.prompt,
          response.error?.message || 'Failed to generate image'
        );
      }

      return response;
    } catch (error) {
      console.error('âŒ Error in FluxService.generateImage:', error);
      return this.createFallbackResponse(
        request.prompt,
        error instanceof Error ? error.message : String(error)
      );
    }
  }

  /**
   * Get a random fallback image or placeholder
   */
  public getFallbackImage(): string {
    if (!this.fallbackEnabled || this.fallbackImages.length === 0) {
      return this.placeholderUrl;
    }

    // Select random image from fallback options
    const randomIndex = Math.floor(Math.random() * this.fallbackImages.length);
    return this.fallbackImages[randomIndex];
  }

  /**
   * Creates a successful response with a fallback image
   */
  private createFallbackResponse(
    prompt: string,
    errorMessage: string
  ): ApiResponse<ImageGenerationResponse> {
    return {
      data: {
        url: this.getFallbackImage(),
        prompt,
        error: {
          code: 'FALLBACK_USED',
          message: errorMessage,
        },
        fallback: true,
      },
      status: 200,
      success: true, // We return success here since we're providing a fallback
    };
  }

  /**
   * Enhances the user prompt for better image generation results
   */
  private enhancePrompt(basePrompt: string, style: string): string {
    const stylePrompts: Record<string, string> = {
      minimalist: 'minimalist style, elegant design, clean composition',
      artistic: 'artistic, creative, expressive, vibrant colors',
      realistic: 'photorealistic, detailed, lifelike, high-definition',
      educational: 'educational, instructive, clear visualization, informative',
    };

    const styleAddition = stylePrompts[style] || stylePrompts.minimalist;

    // Add styling and quality keywords to improve generation results
    return `${basePrompt}, high quality, detailed, 4k, professional, ${styleAddition}`;
  }
}

// Create and export a singleton instance
export const fluxService = new FluxService();```


ğŸŸ¦ File: src/lib/api/enhanced-api-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Enhanced API Service
 *
 * Extends the base API service with circuit breaker pattern for fault isolation
 * and resilience against failing services.
 */
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { ApiResponse, ApiError, ApiServiceConfig } from './types/api-types';
import { validateServiceEnv, ServiceKey } from '../env-validator';
import { CircuitBreaker } from '../error-handling/circuit-breaker';

export class EnhancedApiService {
  protected client: AxiosInstance;
  protected serviceName: string;
  protected config: ApiServiceConfig;
  protected isEnvironmentValid: boolean;
  protected missingEnvVars: string[];
  protected circuitBreaker: CircuitBreaker;

  constructor(serviceName: string, config: ApiServiceConfig) {
    this.serviceName = serviceName;
    this.config = config;

    // Set up circuit breaker
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: config.circuitBreaker?.failureThreshold || 3,
      successThreshold: config.circuitBreaker?.successThreshold || 2,
      timeout: config.circuitBreaker?.timeout || 30000,
      onStateChange: (from, to) => {
        console.log(`ğŸ”Œ [${this.serviceName}] Circuit state changed: ${from} -> ${to}`);
      }
    });

    // Validate environment variables for this service
    const serviceKey = this.getServiceKeyFromName();
    if (serviceKey) {
      const validation = validateServiceEnv(serviceKey);
      this.isEnvironmentValid = validation.valid;
      this.missingEnvVars = validation.missing;

      if (!this.isEnvironmentValid) {
        console.warn(`âš ï¸ [${this.serviceName}] Missing environment variables: ${this.missingEnvVars.join(', ')}`);
      }
    } else {
      this.isEnvironmentValid = true;
      this.missingEnvVars = [];
    }

    // Create axios instance with service configuration
    this.client = axios.create({
      baseURL: config.baseUrl,
      timeout: config.defaultTimeout || 15000,
      headers: {
        'Content-Type': 'application/json',
        ...(config.apiKey && { Authorization: `Bearer ${config.apiKey}` }),
        ...config.defaultHeaders,
      },
    });

    // Add request interceptor for logging
    this.client.interceptors.request.use((request) => {
      if (process.env.NODE_ENV === 'development') {
        console.log(`ğŸ”· [${this.serviceName}] API Request:`, {
          url: request.url,
          method: request.method,
          // Omit sensitive headers like Authorization
          headers: { ...request.headers, Authorization: '[REDACTED]' },
          // Omit sensitive data
          data: this.sanitizeLogData(request.data),
        });
      }
      return request;
    });

    // Add response interceptor for logging
    this.client.interceptors.response.use(
      (response) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`âœ… [${this.serviceName}] API Response:`, {
            status: response.status,
            statusText: response.statusText,
            data: this.sanitizeLogData(response.data),
          });
        }
        return response;
      },
      (error: AxiosError) => {
        // Log error details
        const errorDetails = {
          message: error.message,
          status: error.response?.status,
          data: error.response?.data ? this.sanitizeLogData(error.response.data) : undefined,
          stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
        };

        if (process.env.NODE_ENV === 'development') {
          console.error(`âŒ [${this.serviceName}] API Error:`, errorDetails);
        } else {
          // In production, log without sensitive data
          console.error(`âŒ [${this.serviceName}] API Error: ${error.message} (${error.response?.status || 'No status'})`);
        }

        return Promise.reject(error);
      }
    );
  }

  /**
   * Get the service key from service name for environment validation
   */
  private getServiceKeyFromName(): ServiceKey | null {
    const name = this.serviceName.toLowerCase();
    if (name.includes('flux') || name.includes('replicate')) return 'replicate';
    if (name.includes('perplexity')) return 'perplexity';
    if (name.includes('grok')) return 'grok';
    if (name.includes('anthropic') || name.includes('claude')) return 'anthropic';
    return null;
  }

  /**
   * Check if the service is configured properly with required environment variables
   */
  public isConfigured(): boolean {
    return this.isEnvironmentValid && !!this.config.apiKey;
  }

  /**
   * Get the status of the circuit breaker
   */
  public getCircuitStatus() {
    return this.circuitBreaker.getStatus();
  }

  /**
   * Manually reset the circuit breaker
   */
  public resetCircuit(): void {
    this.circuitBreaker.reset();
    console.log(`ğŸ”„ [${this.serviceName}] Circuit breaker manually reset`);
  }

  /**
   * Sanitize sensitive data before logging
   */
  private sanitizeLogData(data: any): any {
    if (!data) return data;

    // Create a copy to avoid modifying the original
    const sanitized = { ...data };

    // Redact common sensitive fields
    const sensitiveFields = ['apiKey', 'password', 'token', 'secret', 'Authorization', 'auth', 'key'];
    sensitiveFields.forEach((field) => {
      if (typeof sanitized[field] !== 'undefined') {
        sanitized[field] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  /**
   * Process API errors into a standardized format
   */
  protected handleError(error: unknown): ApiError {
    // Handle Axios errors with detailed information
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError<any>;
      const statusCode = axiosError.response?.status;
      const serverMessage = axiosError.response?.data?.error?.message ||
                           axiosError.response?.data?.message;

      // Map status codes to error codes
      const errorCodeMap: Record<number, string> = {
        400: 'BAD_REQUEST',
        401: 'UNAUTHORIZED',
        403: 'FORBIDDEN',
        404: 'NOT_FOUND',
        429: 'RATE_LIMITED',
        500: 'INTERNAL_SERVER_ERROR',
        502: 'BAD_GATEWAY',
        503: 'SERVICE_UNAVAILABLE',
        504: 'GATEWAY_TIMEOUT'
      };

      const errorCode = errorCodeMap[statusCode || 500] || 'API_ERROR';

      return {
        code: errorCode,
        message: serverMessage || axiosError.message || `HTTP Error ${statusCode}`,
        details: {
          status: statusCode,
          url: axiosError.config?.url,
          method: axiosError.config?.method?.toUpperCase(),
          ...(process.env.NODE_ENV === 'development' && {
            data: axiosError.config?.data,
            stack: axiosError.stack
          })
        }
      };
    }

    // Handle standard JavaScript errors
    if (error instanceof Error) {
      return {
        code: 'CLIENT_ERROR',
        message: error.message,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      };
    }

    // Handle unknown error types
    return {
      code: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred',
      details: String(error)
    };
  }

  /**
   * Makes a GET request with circuit breaker protection
   */
  protected async get<T>(
    url: string,
    config?: AxiosRequestConfig,
    retries = 2
  ): Promise<ApiResponse<T>> {
    try {
      // Execute the request through the circuit breaker
      const response = await this.circuitBreaker.execute(async () => {
        try {
          const res = await this.client.get<T>(url, config);
          return {
            data: res.data,
            status: res.status,
            success: true,
          };
        } catch (error) {
          // Retry for specific error conditions
          if (retries > 0 && this.isRetryableError(error)) {
            console.log(`[${this.serviceName}] Retrying GET request to ${url} (${retries} attempts remaining)`);
            // Exponential backoff: wait longer for each retry
            const delay = 1000 * (3 - retries);
            await new Promise(resolve => setTimeout(resolve, delay));
            return this.get<T>(url, config, retries - 1);
          }
          throw error;
        }
      });

      return response;
    } catch (error) {
      return {
        error: this.handleError(error),
        status: this.getErrorStatus(error),
        success: false,
      };
    }
  }

  /**
   * Makes a POST request with circuit breaker protection
   */
  protected async post<T, D = unknown>(
    url: string,
    data?: D,
    config?: AxiosRequestConfig,
    retries = 2
  ): Promise<ApiResponse<T>> {
    try {
      // Execute the request through the circuit breaker
      const response = await this.circuitBreaker.execute(async () => {
        try {
          const res = await this.client.post<T>(url, data, config);
          return {
            data: res.data,
            status: res.status,
            success: true,
          };
        } catch (error) {
          // Retry for specific error conditions
          if (retries > 0 && this.isRetryableError(error)) {
            console.log(`[${this.serviceName}] Retrying POST request to ${url} (${retries} attempts remaining)`);
            // Exponential backoff: wait longer for each retry
            const delay = 1000 * (3 - retries);
            await new Promise(resolve => setTimeout(resolve, delay));
            return this.post<T, D>(url, data, config, retries - 1);
          }
          throw error;
        }
      });

      return response;
    } catch (error) {
      return {
        error: this.handleError(error),
        status: this.getErrorStatus(error),
        success: false,
      };
    }
  }

  /**
   * Check if an error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (axios.isAxiosError(error)) {
      const status = error.response?.status;

      // Network errors or specific status codes that are temporary
      if (!status || status === 429 || status === 503 || status === 504) {
        return true;
      }

      // Retry on connection errors
      if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {
        return true;
      }
    }

    return false;
  }

  /**
   * Get HTTP status from error
   */
  private getErrorStatus(error: unknown): number {
    if (axios.isAxiosError(error) && error.response) {
      return error.response.status;
    }

    // Default status for network errors
    return 0;
  }
}```


ğŸŸ¦ File: src/lib/api/api-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Base API Service
 * Provides core functionality for all API services with consistent error handling and logging
 */
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { ApiResponse, ApiError, ApiServiceConfig } from './types/api-types';
import { validateServiceEnv, ServiceKey } from '../env-validator';

export class ApiService {
  protected client: AxiosInstance;
  protected serviceName: string;
  protected config: ApiServiceConfig;
  protected isEnvironmentValid: boolean;
  protected missingEnvVars: string[];

  constructor(serviceName: string, config: ApiServiceConfig) {
    this.serviceName = serviceName;
    this.config = config;

    // Validate environment variables for this service
    const serviceKey = this.getServiceKeyFromName();
    if (serviceKey) {
      const validation = validateServiceEnv(serviceKey);
      this.isEnvironmentValid = validation.valid;
      this.missingEnvVars = validation.missing;

      if (!this.isEnvironmentValid) {
        console.warn(`âš ï¸ [${this.serviceName}] Missing environment variables: ${this.missingEnvVars.join(', ')}`);
      }
    } else {
      this.isEnvironmentValid = true;
      this.missingEnvVars = [];
    }

    // Create axios instance with service configuration
    this.client = axios.create({
      baseURL: config.baseUrl,
      timeout: config.defaultTimeout || 15000,
      headers: {
        'Content-Type': 'application/json',
        ...(config.apiKey && { Authorization: `Bearer ${config.apiKey}` }),
        ...config.defaultHeaders,
      },
    });

    // Add request interceptor for logging
    this.client.interceptors.request.use((request) => {
      if (process.env.NODE_ENV === 'development') {
        console.log(`ğŸ”· [${this.serviceName}] API Request:`, {
          url: request.url,
          method: request.method,
          // Omit sensitive headers like Authorization
          headers: { ...request.headers, Authorization: '[REDACTED]' },
          // Omit sensitive data
          data: this.sanitizeLogData(request.data),
        });
      }
      return request;
    });

    // Add response interceptor for logging
    this.client.interceptors.response.use(
      (response) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`âœ… [${this.serviceName}] API Response:`, {
            status: response.status,
            statusText: response.statusText,
            data: this.sanitizeLogData(response.data),
          });
        }
        return response;
      },
      (error: AxiosError) => {
        // Log error details
        const errorDetails = {
          message: error.message,
          status: error.response?.status,
          data: error.response?.data ? this.sanitizeLogData(error.response.data) : undefined,
          stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
        };

        if (process.env.NODE_ENV === 'development') {
          console.error(`âŒ [${this.serviceName}] API Error:`, errorDetails);
        } else {
          // In production, log without sensitive data
          console.error(`âŒ [${this.serviceName}] API Error: ${error.message} (${error.response?.status || 'No status'})`);
        }

        return Promise.reject(error);
      }
    );
  }

  /**
   * Get the service key from service name for environment validation
   */
  private getServiceKeyFromName(): ServiceKey | null {
    const name = this.serviceName.toLowerCase();
    if (name.includes('flux') || name.includes('replicate')) return 'replicate';
    if (name.includes('perplexity')) return 'perplexity';
    if (name.includes('grok')) return 'grok';
    if (name.includes('anthropic') || name.includes('claude')) return 'anthropic';
    return null;
  }

  /**
   * Check if the service is configured properly with required environment variables
   */
  public isConfigured(): boolean {
    return this.isEnvironmentValid && !!this.config.apiKey;
  }

  /**
   * Sanitize sensitive data before logging
   */
  private sanitizeLogData(data: any): any {
    if (!data) return data;

    // Create a copy to avoid modifying the original
    const sanitized = { ...data };

    // Redact common sensitive fields
    const sensitiveFields = ['apiKey', 'password', 'token', 'secret', 'Authorization', 'auth', 'key'];
    sensitiveFields.forEach((field) => {
      if (typeof sanitized[field] !== 'undefined') {
        sanitized[field] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  /**
   * Processes API errors into a standardized format
   * Handles different error types and provides detailed information for debugging
   *
   * @param error - Any error object thrown during API operations
   * @returns Standardized ApiError object
   */
  protected handleError(error: unknown): ApiError {
    // Handle Axios errors with detailed information
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError<any>;
      const statusCode = axiosError.response?.status;
      const serverMessage = axiosError.response?.data?.error?.message ||
                           axiosError.response?.data?.message;

      // Map status codes to error codes
      const errorCodeMap: Record<number, string> = {
        400: 'BAD_REQUEST',
        401: 'UNAUTHORIZED',
        403: 'FORBIDDEN',
        404: 'NOT_FOUND',
        429: 'RATE_LIMITED',
        500: 'INTERNAL_SERVER_ERROR',
        502: 'BAD_GATEWAY',
        503: 'SERVICE_UNAVAILABLE',
        504: 'GATEWAY_TIMEOUT'
      };

      const errorCode = errorCodeMap[statusCode || 500] || 'API_ERROR';

      // Log detailed error information for troubleshooting
      console.error(`[API] ${errorCode} error:`, {
        status: statusCode,
        message: serverMessage || axiosError.message,
        url: axiosError.config?.url,
      });

      return {
        code: errorCode,
        message: serverMessage || axiosError.message || `HTTP Error ${statusCode}`,
        details: {
          status: statusCode,
          url: axiosError.config?.url,
          method: axiosError.config?.method?.toUpperCase(),
          ...(process.env.NODE_ENV === 'development' && {
            data: axiosError.config?.data,
            stack: axiosError.stack
          })
        }
      };
    }

    // Handle standard JavaScript errors
    if (error instanceof Error) {
      console.error('[API] Client error:', error.message);
      return {
        code: 'CLIENT_ERROR',
        message: error.message,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      };
    }

    // Handle unknown error types
    console.error('[API] Unknown error:', error);
    return {
      code: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred',
      details: String(error)
    };
  }

  /**
   * Makes a GET request with retry capability for transient errors
   *
   * @param url - Endpoint URL
   * @param config - Axios request configuration
   * @param retries - Number of retry attempts (default: 2)
   * @returns Promise with standardized API response
   */
  protected async get<T>(
    url: string,
    config?: AxiosRequestConfig,
    retries = 2
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get<T>(url, config);
      return {
        data: response.data,
        status: response.status,
        success: true,
      };
    } catch (error) {
      // Retry for specific error conditions
      if (retries > 0 && this.isRetryableError(error)) {
        console.log(`[API] Retrying GET request to ${url} (${retries} attempts remaining)`);
        // Exponential backoff: wait longer for each retry
        const delay = 1000 * (3 - retries);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.get<T>(url, config, retries - 1);
      }

      return {
        error: this.handleError(error),
        status: this.getErrorStatus(error),
        success: false,
      };
    }
  }

  /**
   * Makes a POST request with retry capability for transient errors
   *
   * @param url - Endpoint URL
   * @param data - Request payload
   * @param config - Axios request configuration
   * @param retries - Number of retry attempts (default: 2)
   * @returns Promise with standardized API response
   */
  protected async post<T, D = unknown>(
    url: string,
    data?: D,
    config?: AxiosRequestConfig,
    retries = 2
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.post<T>(url, data, config);
      return {
        data: response.data,
        status: response.status,
        success: true,
      };
    } catch (error) {
      // Retry for specific error conditions
      if (retries > 0 && this.isRetryableError(error)) {
        console.log(`[API] Retrying POST request to ${url} (${retries} attempts remaining)`);
        // Exponential backoff: wait longer for each retry
        const delay = 1000 * (3 - retries);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.post<T, D>(url, data, config, retries - 1);
      }

      return {
        error: this.handleError(error),
        status: this.getErrorStatus(error),
        success: false,
      };
    }
  }

  /**
   * Determines if an error is eligible for retry
   * Typically network errors or server overload conditions
   *
   * @param error - The error to check
   * @returns True if the error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (!axios.isAxiosError(error)) return false;

    // Network errors (no response)
    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT' || !error.response) {
      return true;
    }

    // Server errors that may be transient
    const status = error.response?.status;
    return !!status && [429, 502, 503, 504].includes(status);
  }

  /**
   * Extracts the HTTP status from an error object
   *
   * @param error - The error object
   * @returns HTTP status code or 500 if not available
   */
  private getErrorStatus(error: unknown): number {
    return axios.isAxiosError(error) && error.response?.status
      ? error.response.status
      : 500;
  }
}```


ğŸŸ¦ File: src/lib/api/anthropic-service.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Anthropic Claude Service
 * Handles advanced language understanding with Claude 3.7 Sonnet model
 */
import { ApiService } from './api-service';
import {
  ApiResponse,
  LanguageRequest,
  LanguageResponse
} from './types/api-types';
import { AI_CONFIG } from '@/lib/ai-config';

export class AnthropicService extends ApiService {
  private defaultModel: string;

  constructor() {
    // Get configuration from AI_CONFIG
    const { apiUrl, apiKey, defaultModel } = AI_CONFIG.anthropic || {};

    super('AnthropicService', {
      baseUrl: apiUrl || 'https://api.anthropic.com',
      apiKey,
      defaultHeaders: {
        'anthropic-version': '2023-06-01', // Use the latest API version
        'Content-Type': 'application/json',
      },
      defaultTimeout: 30000, // Claude can take longer for complex queries
    });

    this.defaultModel = defaultModel || 'claude-3-7-sonnet';
  }

  /**
   * Send a query to Claude for advanced language understanding
   */
  public async query(request: LanguageRequest): Promise<ApiResponse<LanguageResponse>> {
    // Check if API key is available
    if (!this.config.apiKey) {
      console.warn('âš ï¸ No Anthropic API key found.');
      return {
        error: {
          code: 'ANTHROPIC_AUTH_ERROR',
          message: 'No API key provided for Anthropic Claude',
        },
        status: 401,
        success: false,
      };
    }

    try {
      // Format request for Claude API
      const claudeRequest = {
        model: this.defaultModel,
        messages: [
          { role: 'user', content: request.query }
        ],
        max_tokens: request.maxTokens || 1000,
        temperature: request.temperature || 0.5,
        system: "You are Claude, a highly sophisticated AI language model specialized in providing detailed linguistic analysis, deep contextual understanding, and precise semantic exploration. Craft thorough, educational responses that help users understand language nuances."
      };

      // Call Claude API with proper endpoint
      const response = await this.post<any>('/v1/messages', claudeRequest);

      // Enhanced logging for development
      if (process.env.NODE_ENV === 'development' && response.data) {
        console.log(`ğŸ§  Claude response for query "${request.query.substring(0, 30)}...":`, {
          model: response.data.model,
          usage: response.data.usage,
        });
      }

      // Transform Claude response format to our standard LanguageResponse
      if (response.success && response.data) {
        const claudeResponse = response.data;

        return {
          data: {
            text: claudeResponse.content?.[0]?.text || '',
            model: claudeResponse.model,
            tokens: {
              total: claudeResponse.usage?.input_tokens + claudeResponse.usage?.output_tokens,
              prompt: claudeResponse.usage?.input_tokens,
              completion: claudeResponse.usage?.output_tokens,
            },
          },
          status: response.status,
          success: true,
        };
      }

      return response as ApiResponse<LanguageResponse>;
    } catch (error) {
      console.error('âŒ Error in AnthropicService.query:', error);

      return {
        error: this.handleError(error),
        status: 500,
        success: false,
      };
    }
  }

  /**
   * Generate detailed linguistic analysis for a word or phrase
   */
  public async analyzeLanguage(text: string): Promise<ApiResponse<any>> {
    if (!this.config.apiKey) {
      return {
        error: {
          code: 'ANTHROPIC_AUTH_ERROR',
          message: 'No API key provided for Anthropic Claude',
        },
        status: 401,
        success: false,
      };
    }

    const systemPrompt = `
    Analyze the provided word or phrase and provide detailed linguistic information including:
    1. Etymology and historical context
    2. Semantic analysis
    3. Common collocations and usage patterns
    4. Related concepts and semantic associations
    5. Register and connotation information

    Format your response as structured JSON with the following sections:
    - etymology
    - semantics
    - usage
    - related
    - register
    `;

    try {
      // Format request for Claude API with our analytical system prompt
      const claudeRequest = {
        model: this.defaultModel,
        messages: [
          { role: 'user', content: text }
        ],
        max_tokens: 2000,
        temperature: 0.2, // Lower temperature for more factual/analytical responses
        system: systemPrompt,
        response_format: { type: "json_object" }
      };

      // Call Claude API
      const response = await this.post<any>('/v1/messages', claudeRequest);

      // Parse JSON response if successful
      if (response.success && response.data && response.data.content) {
        try {
          const content = response.data.content[0]?.text || '{}';
          const parsedAnalysis = JSON.parse(content);

          return {
            data: {
              ...parsedAnalysis,
              model: response.data.model,
              tokens: {
                total: response.data.usage?.input_tokens + response.data.usage?.output_tokens,
                prompt: response.data.usage?.input_tokens,
                completion: response.data.usage?.output_tokens,
              },
            },
            status: response.status,
            success: true,
          };
        } catch (parseError) {
          console.error('âŒ Error parsing JSON from Claude:', parseError);
          return {
            error: {
              code: 'PARSE_ERROR',
              message: 'Failed to parse Claude response as JSON',
              details: parseError instanceof Error ? parseError.message : String(parseError),
            },
            status: 500,
            success: false,
          };
        }
      }

      return response;
    } catch (error) {
      console.error('âŒ Error in AnthropicService.analyzeLanguage:', error);

      return {
        error: this.handleError(error),
        status: 500,
        success: false,
      };
    }
  }
}

// Create and export a singleton instance
export const anthropicService = new AnthropicService();```


ğŸŸ¦ File: src/components/visual-mnemonic.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { useState, useEffect } from 'react';
import Image from 'next/image';
import { useImageGeneration } from '@/hooks/use-image-generation';
import { ImageGenerationResponse } from '@/lib/api/types/api-types';

interface VisualMnemonicProps {
  word: string;
  className?: string;
  onGenerated?: (image: ImageGenerationResponse) => void;
  size?: 'sm' | 'md' | 'lg';
}

/**
 * Visual Mnemonic component for displaying AI-generated images
 * to enhance word retention and understanding
 */
export function VisualMnemonic({
  word,
  className = '',
  onGenerated,
  size = 'md'
}: VisualMnemonicProps) {
  // Use our enhanced image generation hook
  const { generateImage, data, isLoading, error, reset, isFallback } = useImageGeneration(word);
  const [retryCount, setRetryCount] = useState(0);

  // Determine dimensions based on size prop
  const dimensions = {
    sm: { width: 200, height: 200 },
    md: { width: 300, height: 300 },
    lg: { width: 400, height: 400 },
  }[size];

  // Generate image when word changes
  useEffect(() => {
    if (word && word.trim().length > 0) {
      generateImage();

      // Notify parent component when image is generated
      if (data && onGenerated) {
        onGenerated(data);
      }
    }
  }, [word, generateImage, data, onGenerated]);

  // Handle retry button click
  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
    reset();
    generateImage();
  };

  // Render loading state
  if (isLoading) {
    return (
      <div className={`glass-effect flex flex-col items-center justify-center ${className}`} style={dimensions}>
        <div className="h-10 w-10 rounded-full border-2 border-primary border-t-transparent animate-spin mb-2"></div>
        <p className="text-sm text-muted-foreground">Generating visual for "{word}"...</p>
        <p className="text-xs text-muted-foreground mt-1">This may take a moment</p>
      </div>
    );
  }

  // Render error state with retry option
  if (error && !data) {
    return (
      <div className={`glass-effect flex flex-col items-center justify-center p-4 ${className}`} style={dimensions}>
        <div className="text-destructive mb-2">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 8V12M12 16H12.01M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z"
                  stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
          </svg>
        </div>
        <p className="text-sm">Failed to generate visual</p>
        <button
          onClick={handleRetry}
          className="mt-2 text-xs bg-primary/10 hover:bg-primary/20 text-primary px-2 py-1 rounded-full transition-colors"
        >
          Try Again
        </button>
      </div>
    );
  }

  // Render generated image or fallback
  if (data) {
    return (
      <div className={`relative ${className}`} style={dimensions}>
        <div className="glass-effect absolute inset-0 overflow-hidden rounded-xl">
          <Image
            src={data.url}
            alt={`Visual representation of ${word}`}
            fill
            className="object-cover transition-opacity"
            sizes={`(max-width: 768px) 100vw, ${dimensions.width}px`}
            priority
          />

          {/* Show fallback badge if using fallback image */}
          {isFallback && (
            <div className="absolute bottom-2 right-2 bg-background/80 text-xs px-2 py-1 rounded-full">
              Fallback Image
            </div>
          )}

          {/* Retry button for fallback images */}
          {isFallback && retryCount < 2 && (
            <button
              onClick={handleRetry}
              className="absolute top-2 right-2 bg-background/80 hover:bg-background/95 text-xs px-2 py-1 rounded-full transition-colors"
            >
              Retry
            </button>
          )}
        </div>
      </div>
    );
  }

  // Render empty state
  return (
    <div className={`glass-effect flex items-center justify-center ${className}`} style={dimensions}>
      <p className="text-sm text-muted-foreground">Enter a word to generate a visual</p>
    </div>
  );
}```


ğŸŸ¦ File: src/components/ui/tabs.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

/**
 * Tabs component using Radix UI
 *
 * This component provides a tabs interface for switching between different views.
 * It's implemented following the shadcn/ui pattern with Radix UI as the base.
 */

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted/20 p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };```


ğŸŸ¦ File: src/components/ui/piya-logo.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { motion } from "framer-motion";
import { useState } from "react";
import { cn } from "@/lib/utils";
import Image from "next/image";

export function PiyaLogo({ className }: { className?: string }) {
  const [isHovering, setIsHovering] = useState(false);

  // Acronym: Powerfull Intelligent You Are
  const acronym = {
    P: "Powerfull",
    I: "Intelligent",
    Y: "You",
    A: "Are",
    ai: "Accelerating Insights"
  };

  return (
    <div
      className={cn("relative group", className)}
      onMouseEnter={() => setIsHovering(true)}
      onMouseLeave={() => setIsHovering(false)}
      onTouchStart={() => setIsHovering(true)}
      onTouchEnd={() => setTimeout(() => setIsHovering(false), 3000)}
    >
      <motion.div
        className="flex items-center gap-1"
        initial={{ opacity: 1 }}
        animate={{ opacity: 1 }}
      >
        <Image
          src="/piya-logo-v1.png"
          alt="PIYA.ai"
          width={120}
          height={40}
          className="object-contain h-10"
          priority
        />
      </motion.div>

      {isHovering && (
        <motion.div
          className="absolute top-full left-0 mt-2 p-3 rounded-lg glass-effect z-50 text-sm w-72 sm:w-60"
          initial={{ opacity: 0, y: -5 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.2 }}
        >
          <div className="space-y-1 text-left">
            <div className="flex gap-2">
              <span className="font-bold text-purple-500">P</span>
              <span>{acronym.P}</span>
            </div>
            <div className="flex gap-2">
              <span className="font-bold text-blue-500">I</span>
              <span>{acronym.I}</span>
            </div>
            <div className="flex gap-2">
              <span className="font-bold text-indigo-500">Y</span>
              <span>{acronym.Y}</span>
            </div>
            <div className="flex gap-2">
              <span className="font-bold text-violet-500">A</span>
              <span>{acronym.A}</span>
            </div>
            <div className="flex gap-2">
              <span className="font-bold text-gray-400 text-xs">.ai</span>
              <span className="text-xs">{acronym.ai}</span>
            </div>
          </div>
        </motion.div>
      )}
    </div>
  );
}```


ğŸŸ¦ File: src/components/ui/button.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

// Define button variants using class-variance-authority
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        glass: "glass-effect hover:bg-accent/10"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

// Button component props interface
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

/**
 * Button Component
 *
 * A versatile button component with multiple variants and sizes
 * Following the glassmorphic design language of Deep Wordsmith
 */
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };```


ğŸŸ¦ File: src/components/theme-provider.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import type { ThemeProviderProps } from "next-themes/dist/types";

/**
 * Theme Provider component that wraps the application to provide theme context
 * @param props - Theme provider props (children, defaultTheme, etc.)
 * @returns Theme provider component
 */
export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}```


ğŸŸ¦ File: src/components/search-bar.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
"use client";

import { useState, useRef, useEffect } from 'react';
import { debounce } from '@/lib/utils';
import { VisualMnemonic } from './visual-mnemonic';
import { ImageGenerationResponse } from '@/lib/ai-config';

/**
 * Enhanced SearchBar component with visual mnemonic integration
 * Features glassmorphic design and debounced search
 */
export default function SearchBar() {
  const [query, setQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [generatedImage, setGeneratedImage] = useState<ImageGenerationResponse | null>(null);

  const resultsRef = useRef<HTMLDivElement>(null);

  // Close results when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (resultsRef.current && !resultsRef.current.contains(event.target as Node)) {
        setShowResults(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Mock search function that would connect to Perplexity/Grok API
  const handleSearch = debounce((searchQuery: string) => {
    // Log for development purposes
    console.log(`ğŸ” Searching for word: ${searchQuery}`);

    if (searchQuery.length > 0) {
      setIsSearching(true);
      // Simulate API delay
      setTimeout(() => {
        setIsSearching(false);
        setShowResults(true);
      }, 1500);
    } else {
      setShowResults(false);
    }
  }, 500);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setQuery(value);
    handleSearch(value);
  };

  // Handle image generation completion
  const handleImageGenerated = (image: ImageGenerationResponse) => {
    console.log(`ğŸ–¼ï¸ Image generated for "${query}":`, image.fallback ? '(fallback)' : '(from API)');
    setGeneratedImage(image);
  };

  return (
    <div className="relative" ref={resultsRef}>
      <div className="relative flex items-center">
        <div className="absolute left-4 text-muted-foreground">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 21L15 15M17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10Z"
              stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
          </svg>
        </div>

        <input
          type="text"
          placeholder="Enter a word to explore..."
          value={query}
          onChange={handleInputChange}
          className="w-full bg-background/70 dark:bg-background/40 h-14 px-12 rounded-full border border-input focus:border-primary focus:ring-1 focus:ring-primary transition-colors focus:outline-none placeholder:text-muted-foreground/70"
        />

        {isSearching && (
          <div className="absolute right-4">
            <div className="h-5 w-5 rounded-full border-2 border-primary border-t-transparent animate-spin" />
          </div>
        )}
      </div>

      {/* Search results with visual mnemonic */}
      {query.length > 0 && showResults && !isSearching && (
        <div className="glass-effect-intense absolute top-full left-0 right-0 mt-4 p-6 rounded-xl z-10">
          <div className="flex flex-col md:flex-row gap-6">
            {/* Left column: Visual mnemonic */}
            <div className="md:w-1/3">
              <VisualMnemonic
                word={query}
                size="sm"
                className="w-full aspect-square"
                onGenerated={handleImageGenerated}
              />
              <p className="text-center text-xs text-muted-foreground mt-2">
                {generatedImage?.fallback
                  ? 'Visual representation from our library'
                  : 'AI-generated visual representation'}
              </p>
            </div>

            {/* Right column: Word details */}
            <div className="md:w-2/3">
              <div className="mb-4">
                <h3 className="text-xl font-semibold">{query}</h3>
                <p className="text-sm text-muted-foreground">Visual language exploration</p>
              </div>

              <div className="space-y-4">
                <div className="glass-effect p-3 rounded-lg">
                  <p className="text-sm font-medium mb-1">Sign up to access:</p>
                  <ul className="text-sm space-y-1 text-muted-foreground">
                    <li>â€¢ Complete definition and etymology</li>
                    <li>â€¢ Related words and concepts</li>
                    <li>â€¢ Contextual usage examples</li>
                    <li>â€¢ AI-powered semantic clusters</li>
                  </ul>
                </div>

                <div className="flex items-center gap-2">
                  <button className="bg-primary text-primary-foreground py-2 px-4 rounded-full text-sm">
                    Sign Up Free
                  </button>
                  <button className="text-sm text-muted-foreground">Learn More</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}```


ğŸŸ¦ File: src/components/loaders/spinner.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
/**
 * Spinner Component
 *
 * A flexible, size-customizable spinner with the app's glassmorphic design
 */
export function Spinner({
  size = 'md',
  className = '',
}) {
  // Size mapping
  const sizeMap = {
    sm: 'w-4 h-4 border-2',
    md: 'w-8 h-8 border-2',
    lg: 'w-12 h-12 border-3',
    xl: 'w-16 h-16 border-4',
  };

  const sizeClass = sizeMap[size as keyof typeof sizeMap] || sizeMap.md;

  return (
    <div
      className={`
        ${sizeClass}
        rounded-full
        border-primary
        border-t-transparent
        animate-spin
        ${className}
      `}
      aria-label="Loading"
      role="status"
    />
  );
}```


ğŸŸ¦ File: src/components/loaders/skeleton.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
import { cn } from "@/lib/utils";

interface SkeletonProps {
  className?: string;
  variant?: 'default' | 'glass';
}

/**
 * Skeleton Component
 *
 * A skeleton loader component for placeholder UI
 * Uses glassmorphic design language to match the app's aesthetic
 */
export function Skeleton({
  className,
  variant = 'default'
}: SkeletonProps) {
  return (
    <div
      className={cn(
        "animate-pulse rounded-md",
        variant === 'glass'
          ? "glass-effect bg-transparent"
          : "bg-muted/40",
        className
      )}
      aria-busy="true"
      aria-hidden="true"
    />
  );
}

interface SkeletonParagraphProps {
  lines?: number;
  className?: string;
  lineClassName?: string;
  variant?: 'default' | 'glass';
}

/**
 * Paragraph Skeleton
 *
 * Creates multiple line skeletons to represent a paragraph of text
 */
export function SkeletonParagraph({
  lines = 3,
  className = '',
  lineClassName = '',
  variant = 'default'
}: SkeletonParagraphProps) {
  return (
    <div className={`space-y-2 ${className}`}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton
          key={i}
          className={cn(
            "h-4",
            // Vary the widths to make it look more natural
            i === lines - 1 ? "w-3/4" : "w-full",
            lineClassName
          )}
          variant={variant}
        />
      ))}
    </div>
  );
}

interface SkeletonImageProps {
  className?: string;
  aspectRatio?: string;
}

/**
 * Image Skeleton
 *
 * A specialized skeleton for image placeholders
 */
export function SkeletonImage({
  className = '',
  aspectRatio = 'aspect-square'
}: SkeletonImageProps) {
  return (
    <div className={`relative ${aspectRatio} ${className}`}>
      <Skeleton className="absolute inset-0" variant="glass" />
      <div className="absolute inset-0 flex items-center justify-center">
        <svg
          className="w-10 h-10 text-muted-foreground/30"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={1.5}
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          />
        </svg>
      </div>
    </div>
  );
}```


ğŸŸ¦ File: src/components/loaders/index.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
/**
 * Loading Components Export
 * Central export for all loading components
 */

// Import the components directly for internal use
import { Spinner } from './spinner';
import {
  Skeleton,
  SkeletonParagraph,
  SkeletonImage
} from './skeleton';

// Re-export all components
export { Spinner } from './spinner';
export {
  Skeleton,
  SkeletonParagraph,
  SkeletonImage
} from './skeleton';

/**
 * Word Loading Component
 *
 * A specialized loading component for word search and exploration
 */
export function WordLoading() {
  return (
    <div className="glass-effect p-6 rounded-xl flex flex-col items-center justify-center space-y-4">
      <div className="flex items-center justify-center">
        <Spinner size="lg" />
      </div>
      <p className="text-muted-foreground text-sm">Exploring linguistic possibilities...</p>
    </div>
  );
}

/**
 * Visual Mnemonic Loading Component
 *
 * A loading component specifically for visual mnemonic generation
 */
export function VisualMnemonicLoading({
  className = '',
  word = 'word'
}: {
  className?: string;
  word?: string;
}) {
  return (
    <div className={`glass-effect rounded-xl flex flex-col items-center justify-center p-4 aspect-square ${className}`}>
      <Spinner size="md" className="mb-3" />
      <p className="text-xs text-muted-foreground text-center">
        Visualizing "{word}"...
      </p>
    </div>
  );
}```


ğŸŸ¦ File: src/components/error-boundary/index.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
'use client';

import React from 'react';
import { ErrorBoundary as ReactErrorBoundary, FallbackProps } from 'react-error-boundary';
import { ErrorFallback } from './error-fallback';

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  fallbackTitle?: string;
  fallbackSubtitle?: string;
  showDetails?: boolean;
  className?: string;
  onError?: (error: Error, info: React.ErrorInfo) => void;
  onReset?: () => void;
}

/**
 * Error Boundary Component
 *
 * A wrapper component that catches errors in its children and displays a fallback UI
 * Uses the react-error-boundary package with our custom styling
 */
export function ErrorBoundary({
  children,
  fallback,
  fallbackTitle,
  fallbackSubtitle,
  showDetails,
  className,
  onError,
  onReset,
}: ErrorBoundaryProps) {
  // Log errors to console and potentially to an error tracking service
  const handleError = (error: Error, info: React.ErrorInfo) => {
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error caught by ErrorBoundary:', error);
      console.error('Component stack:', info.componentStack);
    }

    // Call custom error handler if provided
    if (onError) {
      onError(error, info);
    }

    // Here you could also log to an error tracking service like Sentry
    // if available in the future
  };

  return (
    <ReactErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }: FallbackProps) =>
        fallback ? (
          <>{fallback}</>
        ) : (
          <ErrorFallback
            error={error}
            resetErrorBoundary={resetErrorBoundary}
            title={fallbackTitle}
            subtitle={fallbackSubtitle}
            showDetails={showDetails}
            className={className}
          />
        )
      }
      onError={handleError}
      onReset={onReset}
    >
      {children}
    </ReactErrorBoundary>
  );
}

// Re-export the fallback component for direct use
export { ErrorFallback } from './error-fallback';```


ğŸŸ¦ File: src/components/error-boundary/error-fallback.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
import { FallbackProps } from 'react-error-boundary';
import { Button } from '@/components/ui/button';
import { useEffect } from 'react';

interface ErrorFallbackProps extends FallbackProps {
  title?: string;
  subtitle?: string;
  showDetails?: boolean;
  className?: string;
  onReport?: (error: Error) => void;
}

/**
 * Error Fallback Component
 *
 * A visually polished fallback component shown when an error is caught by an ErrorBoundary
 * Maintains the app's glassmorphic design language while providing helpful error information
 */
export function ErrorFallback({
  error,
  resetErrorBoundary,
  title = 'Something went wrong',
  subtitle = 'We encountered an unexpected error',
  showDetails = process.env.NODE_ENV === 'development',
  className = '',
  onReport,
}: ErrorFallbackProps) {
  // Auto-log errors
  useEffect(() => {
    // Log to console
    console.error('Error caught by ErrorBoundary:', error);

    // Report error to analytics or monitoring service
    if (typeof window !== 'undefined' && onReport) {
      onReport(error);
    }

    // For non-development environments, you could implement
    // integration with error monitoring services like Sentry
    if (process.env.NODE_ENV !== 'development') {
      // Example of Sentry integration
      // window.Sentry?.captureException(error);

      // Example of logging to analytics
      try {
        if (typeof window !== 'undefined' && window.gtag) {
          window.gtag('event', 'exception', {
            description: error.message,
            fatal: true,
          });
        }
      } catch (loggingError) {
        console.error('Error reporting to analytics:', loggingError);
      }
    }
  }, [error, onReport]);

  // Function to handle recovery
  const handleRecovery = () => {
    // Attempt to reset the error boundary
    resetErrorBoundary();

    // If no reset handler provided, refresh the page as a last resort
    if (!resetErrorBoundary) {
      window.location.reload();
    }
  };

  return (
    <div className={`glass-effect p-6 rounded-xl overflow-hidden ${className}`}>
      <div className="flex flex-col items-center text-center space-y-4">
        {/* Error icon */}
        <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/20 flex items-center justify-center text-red-600 dark:text-red-400">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" />
            <path d="M12 7v6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
            <path d="M12 17v.01" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
          </svg>
        </div>

        {/* Error title and message */}
        <div>
          <h3 className="text-lg font-medium">{title}</h3>
          <p className="text-sm text-muted-foreground mt-1">{subtitle}</p>
        </div>

        {/* Show error details in dev mode */}
        {showDetails && (
          <div className="w-full bg-muted/40 dark:bg-muted/20 rounded-lg p-3 mt-2 overflow-auto text-left">
            <p className="text-xs font-mono break-all whitespace-pre-wrap">
              {error.name}: {error.message}
              {error.stack && (
                <>
                  <br />
                  <br />
                  {error.stack}
                </>
              )}
            </p>
          </div>
        )}

        {/* Recovery options */}
        <div className="mt-4 flex gap-2">
          <Button onClick={handleRecovery} variant="default">
            Try again
          </Button>

          <Button
            onClick={() => window.location.href = '/'}
            variant="outline"
          >
            Go to home page
          </Button>
        </div>

        {/* Feedback option */}
        {process.env.NODE_ENV === 'production' && (
          <p className="text-xs text-muted-foreground mt-4">
            If this problem persists, please contact support.
          </p>
        )}
      </div>
    </div>
  );
}```


ğŸ“š File: docs/semantic-clustering-plan.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```md
# Semantic Clustering Visualization Plan

## Overview

The semantic clustering visualization is a core differentiating feature of Deep Words. It will display related words and concepts as an interactive network, allowing users to explore linguistic connections in a visually intuitive way.

## Technical Approach

### 1. Data Structure

We will represent semantic relationships as a graph:

```typescript
interface SemanticNode {
  id: string;          // Word ID
  word: string;        // The actual word
  type: 'primary' | 'synonym' | 'antonym' | 'related' | 'root';
  weight: number;      // Relationship strength (0-1)
  definitions?: string[];
  etymology?: string;
}

interface SemanticLink {
  source: string;      // Source node ID
  target: string;      // Target node ID
  type: 'synonym' | 'antonym' | 'related' | 'derivation';
  weight: number;      // Relationship strength (0-1)
}

interface SemanticGraph {
  nodes: SemanticNode[];
  links: SemanticLink[];
}
```

### 2. Data Generation

For each word search, we'll use the Perplexity or Grok API to:

1. Get synonyms, antonyms, and related terms
2. Generate similarity scores between terms
3. Determine conceptual groupings
4. Create a hierarchical structure of relationships

### 3. Visualization

We will implement the visualization using:

- **D3.js** or **react-force-graph** for the core graph visualization
- Custom rendering with **Tailwind CSS** for the glassmorphic style
- **Framer Motion** for animations and interactions

### 4. User Interactions

The visualization will support:

- **Zooming** to focus on specific clusters
- **Panning** to navigate the semantic landscape
- **Clicking** on nodes to see detailed information
- **Dragging** nodes to reorganize the visualization
- **Highlighting** paths between selected words
- **Filtering** by relationship type or strength

## Implementation Phases

### Phase 1: Data Integration

1. Create API route for semantic data generation
2. Integrate with Perplexity/Grok
3. Implement data transformation and filtering
4. Add caching layer for performance

### Phase 2: Basic Visualization

1. Implement force-directed graph layout
2. Create basic node and link rendering
3. Add basic interactions (click, hover)
4. Integrate with the search functionality

### Phase 3: Enhanced Interactions

1. Add animations for transitions
2. Implement semantic zooming
3. Add filtering and highlighting
4. Enable saving and sharing visualizations

### Phase 4: Refinement

1. Optimize performance for larger graphs
2. Add accessibility features
3. Implement responsive design adaptations
4. Polish visual design and animations

## Mockup Design

```
                  +------------+
                  | "eloquent" |
                  +------------+
                        |
         +-----------------------------+
         |              |              |
    +-----------+ +------------+ +------------+
    | "articul- | | "fluent"   | | "persuasi-|
    |  ate"     | |            | |  ve"       |
    +-----------+ +------------+ +------------+
         |              |              |
    +-----------+ +------------+ +------------+
    | "verbal"  | | "smooth"   | | "compell- |
    |           | |            | |  ing"      |
    +-----------+ +------------+ +------------+
```

## Technical Considerations

### Performance

- Limit initial visualization to ~30 nodes for performance
- Use WebGL rendering for larger graphs
- Implement progressive loading for expanded exploration
- Use web workers for layout calculations

### Accessibility

- Provide keyboard navigation
- Include screen reader descriptions
- Offer alternative text-based view
- Support high contrast mode

### Mobile Experience

- Adapt visualization for touch interactions
- Simplify view on smaller screens
- Use responsive sizing
- Optimize touch targets

## Integration with Visual Mnemonics

The semantic clustering will integrate with visual mnemonics by:

1. Showing small visual indicators for nodes with available visuals
2. Allowing visual preview on hover
3. Using visual themes to represent different semantic domains
4. Enabling users to switch between text and visual modes

## Resources and References

- [Force-directed Graph Layout Algorithm](https://en.wikipedia.org/wiki/Force-directed_graph_drawing)
- [D3.js Force Layout](https://github.com/d3/d3-force)
- [React Force Graph](https://github.com/vasturiano/react-force-graph)
- [Framer Motion API](https://www.framer.com/motion/)
- [Semantic Network Visualization Best Practices](https://www.visualcinnamon.com/2015/11/learnings-from-a-d3-js-addict-on-starting-with-canvas/)

## Next Steps

1. Create an API route skeleton for semantic data
2. Implement a basic proof-of-concept visualization
3. Define the data transformation pipeline
4. Benchmark performance and refine approach```


ğŸ“š File: docs/authentication-plan.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```md
# Authentication and User Management Plan

## Overview

Authentication and user management are essential for Deep Words to offer personalized experiences, save user history, and implement the subscription model outlined in the PRD. This document outlines the approach for implementing a secure, scalable authentication system.

## Technical Approach

We will implement authentication using NextAuth.js (Auth.js), which provides a flexible, secure framework for handling authentication in Next.js applications.

### 1. Authentication Providers

We'll support the following authentication methods:

- **Email/Password**: Traditional signup with email verification
- **OAuth**: Social login via:
  - Google
  - GitHub
  - Apple (for mobile users)
- **Magic Links**: Passwordless email login

### 2. User Data Structure

```typescript
interface User {
  id: string;
  email: string;
  name?: string;
  image?: string;
  plan: 'free' | 'professional' | 'enterprise';
  createdAt: Date;
  updatedAt: Date;
  settings: UserSettings;
}

interface UserSettings {
  theme: 'light' | 'dark' | 'system';
  visualMnemonicsEnabled: boolean;
  semanticClusteringEnabled: boolean;
  historyEnabled: boolean;
}
```

### 3. Database Integration

We'll use Prisma with PostgreSQL for user data storage:

```typescript
// Prisma schema excerpt
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  plan          String    @default("free")
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]
  sessions      Session[]
  searches      Search[]
  collections   Collection[]
}

model Search {
  id        String   @id @default(cuid())
  query     String
  timestamp DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Collection {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  words       Word[]
}

model Word {
  id           String     @id @default(cuid())
  word         String
  collectionId String
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
}
```

## Implementation Phases

### Phase 1: Basic Authentication

1. Set up NextAuth.js with a simple provider (Google)
2. Create login/signup pages with glassmorphic design
3. Implement protected routes and middleware
4. Add user context provider for client components

### Phase 2: User Profiles and Settings

1. Create user profile page
2. Implement settings management
3. Add avatar and personal information editing
4. Implement theme preferences

### Phase 3: Subscription Integration

1. Add subscription tiers
2. Integrate with Stripe for payments
3. Implement feature gating based on subscription
4. Add subscription management UI

### Phase 4: Advanced Features

1. Implement organization accounts for enterprise tier
2. Add team collaboration features
3. Implement API key generation for developer access
4. Add SSO for enterprise accounts

## User Experience Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Landing    â”‚â”€â”€â”€â”€>â”‚  Sign Up    â”‚â”€â”€â”€â”€>â”‚ Onboarding  â”‚
â”‚  Page       â”‚     â”‚  / Login    â”‚     â”‚  Flow       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Settings   â”‚<â”€â”€â”€â”€â”‚  Dashboard  â”‚<â”€â”€â”€â”€â”‚ Feature     â”‚
â”‚  Profile    â”‚     â”‚  Home       â”‚     â”‚ Exploration â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                    â–²                   â”‚
      â”‚                    â”‚                   â–¼
      â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ Subscriptionâ”‚<â”€â”€â”€â”€â”‚ Feature     â”‚
                     â”‚ Management  â”‚     â”‚ Limitation  â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Security Considerations

1. **CSRF Protection**: Implemented via NextAuth.js built-in protection
2. **Rate Limiting**: Apply rate limiting to login attempts
3. **Password Requirements**: Strong password policies
4. **Session Management**: Secure handling of sessions with proper expiration
5. **API Endpoint Protection**: Middleware to verify auth status

## Subscription Tiers Implementation

### Free Tier
- Limited searches per day
- Basic word information
- No history saving
- No collections
- Visual mnemonics with watermark

### Professional Tier ($9.99/month)
- Unlimited searches
- Full word information
- History and collections
- High-quality visual mnemonics
- Export functionality
- Semantic clustering

### Enterprise Tier ($49.99/month)
- All Professional features
- Team collaboration
- SSO integration
- API access
- Custom branding
- Priority support

## Technical Implementation Details

### NextAuth.js Configuration

```typescript
// Example NextAuth configuration
export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID as string,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
    }),
    CredentialsProvider({
      // Implementation details
    }),
    // Other providers
  ],
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: '/auth/signin',
    signOut: '/auth/signout',
    error: '/auth/error',
    verifyRequest: '/auth/verify-request',
    newUser: '/auth/new-user'
  },
  callbacks: {
    // Custom callbacks for extending functionality
  },
};
```

### Route Protection Middleware

```typescript
// Example middleware for protecting routes
export default function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;

  // Check if the path is protected
  if (isProtectedRoute(pathname)) {
    const token = request.cookies.get('next-auth.session-token');

    if (!token) {
      const url = new URL('/auth/signin', request.url);
      url.searchParams.set('callbackUrl', pathname);
      return NextResponse.redirect(url);
    }
  }

  return NextResponse.next();
}
```

## Next Steps

1. Set up NextAuth.js with basic configuration
2. Create authentication UI components
3. Implement Prisma schema for user data
4. Add protected routes for user-specific features
5. Create user context provider for client state```


ğŸ“š File: PRD-DRAFT.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```md
# DEEP WORDSMITH: PRODUCT REQUIREMENTS DOCUMENT

## Product Overview
Deep Wordsmith is a neural-enhanced linguistic exploration platform that serves as an extension of the creative mind. It transcends conventional reference tools by integrating multi-modal AI (Perplexity, Grok, Anthropic Claude, and Replicate Flux) to create a seamless bridge between language conception and expression, offering professionals contextually-aware semantic landscapes visualized through sophisticated design.

## Market Problem & Opportunity
Traditional thesaurus and language reference tools lack:
1. Visual representation of linguistic concepts
2. Contextual understanding of the user's intent
3. Premium, frictionless UX designed for creative flow
4. Personalized language experiences that learn from usage

Deep Wordsmith addresses these gaps by creating a premium, AI-enhanced experience that transforms language exploration from a utilitarian reference task to an inspirational creative process.

## Target Users
- Writers (professional and aspiring)
- Content creators
- Marketing professionals
- Academics and researchers
- Creative professionals in various fields
- Non-native English speakers seeking nuanced expression

## Value Proposition
Deep Wordsmith empowers users to:
- Discover perfect word choices faster with AI that understands context
- Visualize linguistic concepts through generated imagery that enhances retention
- Explore semantic landscapes rather than flat lists of synonyms
- Maintain a persistent, personalized language workspace that evolves with use
- Access an aesthetically stunning interface that enhances creative flow

## Key Features and Requirements

### 1. Core Search Experience
- **Contextual Word Search**: Use AI to understand the user's context when searching for words
- **Semantic Clustering**: Display results in visual clusters showing relationships between concepts
- **Visual Mnemonics**: Generate relevant imagery to enhance understanding and retention
- **Historical Context**: Show etymology and evolution of words when relevant

### 2. AI Integration
- **Perplexity API**: For deep contextual language understanding and generation âœ…
- **Grok API**: For creative and divergent word suggestions âœ…
- **Replicate Flux**: For generating visual representations of words and concepts âœ…
- **Anthropic Claude**: For advanced linguistic analysis and etymology exploration âœ…

### 3. User Interface & Experience
- **Glassmorphic Design**: VisionOS-inspired translucent interface elements âœ…
- **Touch Optimization**: Intuitive gesture controls for mobile and tablet use
- **Dark/Light Mode**: Automatic and manual theme switching âœ…
- **Responsive Design**: Full functionality across devices of all sizes âœ…

### 4. User Personalization
- **User Accounts**: Secure login with OAuth options
- **History Timeline**: Visualized journey of word explorations
- **Personal Collections**: Ability to save word clusters for future reference
- **AI Tuning**: User-adjustable AI creativity level slider

### 5. Export & Integration
- **One-Click Export**: Save word collections to various formats
- **Integration with Creative Tools**: Direct export to Notion, Google Docs, etc.
- **API Access**: For power users to integrate with custom workflows

### 6. Monetization Strategy
- **Tiered Subscription Model**:
  - Free Tier: Basic word search with limited AI suggestions
  - Professional Tier ($9.99/month): Full AI features, export options
  - Enterprise Tier ($49.99/month): Team collaboration, API access, priority support

### 7. Performance Requirements
- **Response Time**: <500ms for text results, <3s for visual elements âœ…
- **Availability**: 99.9% uptime
- **Offline Capability**: Basic functionality without internet connection

## Implementation Phases

### Phase 1: MVP (Completed) âœ…
- Core API service layer with proper error handling and fallbacks
- Integration with Replicate, Perplexity, Grok, and Anthropic
- Data caching strategy with SWR for optimized performance
- Basic UI components with glassmorphic design
- Error boundaries and loading states
- Responsive layouts with Tailwind CSS

### Phase 2: Enhanced Features (In Progress)
- User authentication and account management
- Semantic clustering visualization
- Personalized collections and history
- Export functionality
- Deployment pipeline and monitoring

### Phase 3: Premium Features (Planned)
- Team collaboration features
- Advanced analytics for language usage
- API access for developers
- Mobile-optimized experience
- Subscription management

## Technical Architecture

### Current Implementation âœ…

#### 1. API Service Layer
- **Base Service**: Abstract base class with standardized error handling
- **Flux Service**: Image generation with fallbacks
- **Perplexity Service**: Contextual language understanding
- **Grok Service**: Creative word suggestions
- **Anthropic Service**: Advanced linguistic analysis

#### 2. Caching Strategy
- **SWR**: Smart caching with stale-while-revalidate pattern
- **Custom Hooks**: Type-safe hooks for each service
- **Optimistic Updates**: For improved perceived performance
- **Graduated Caching**: Different strategies for different data types

#### 3. Error Handling
- **Error Boundaries**: Component-level error isolation
- **Fallback UI**: Consistent error displays
- **Service Fallbacks**: Mock data generation when services unavailable
- **Retry Logic**: Automatic retries for transient failures

#### 4. UI Components
- **Glassmorphic Design System**: Custom Tailwind extensions
- **Loading States**: Skeleton loaders and spinners
- **Responsive Layouts**: Mobile-first approach
- **Accessibility**: ARIA attributes and keyboard navigation

### Planned Enhancements

#### 1. Authentication & User Management
- **NextAuth.js**: For secure authentication
- **Prisma**: For database access
- **JWT**: For stateless sessions
- **Role-Based Access**: For different subscription tiers

#### 2. Semantic Clustering
- **Force-Directed Graph**: For visualizing word relationships
- **D3.js**: For interactive visualizations
- **Clustering Algorithm**: For organizing related concepts
- **User Interaction**: For exploring the semantic space

#### 3. Export & Integration
- **PDF Generation**: For downloadable summaries
- **Markdown Export**: For easy integration with note-taking apps
- **API Endpoints**: For programmatic access
- **OAuth Integration**: For third-party service connections

## Success Metrics
- User acquisition: 10,000 users within first 3 months
- Retention: >40% monthly active user retention
- Conversion: 5% free-to-paid conversion rate
- Engagement: Average session time >3 minutes
- NPS: Net Promoter Score >40 within 6 months

## Deployment Strategy

### Current Deployment Plan âœ…
1. **Vercel**: Primary hosting platform
2. **GitHub**: Version control and CI/CD
3. **Environment Variables**: Secure API key management
4. **Monitoring**: Basic error tracking and analytics

### Future Enhancements
1. **Edge Functions**: For low-latency global access
2. **CDN**: For static asset delivery
3. **Server-Side Rendering**: For improved SEO and performance
4. **Serverless Functions**: For scalable API endpoints

## Risks and Mitigations
1. **API Costs**: Implement caching strategies and result reuse to minimize API calls âœ…
2. **User Adoption**: Focus on free tier value to drive organic growth before monetization
3. **Competitive Response**: Maintain rapid innovation cycle to stay ahead of market
4. **Performance Issues**: Implement progressive loading and optimization strategies âœ…

## Conclusion
Deep Wordsmith represents a paradigm shift in language reference tools, moving from utilitarian word lists to an immersive, AI-enhanced creative companion. Our implementation has established a solid foundation with a robust API service layer, efficient caching, and an elegant UI system. By continuing to execute on this vision with a focus on premium UX and genuine user value, we aim to create not just a product but an indispensable tool in the creative arsenal of professionals worldwide.```


ğŸ“š File: .specstory/history/deep-wordsmith-project-codebase-analysis.md
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```md
## SpecStory

## Deep Wordsmith Project Codebase Analysis (2/24/2025, 2:01:04 PM)

_**User**_

perform a thorough analysis of this entire repository using the new Claude 3.7 Sonnet with thinking, identify areas that can be improved and suggest optimizations. Based on your findings give a Command Prompt for me to enter into the composer agent on Cursor AI composer to implement your suggested observations and next steps in the form of an English language prompt that I can copy and paste into the Cursor composer agent input window. Look up anything that you might need to get a refresher on. Inverse the entire code base please. @Web @Codebase 

---

_**Assistant**_

<think>
Let me analyze the provided codebase for the "Deep Wordsmith" project to identify potential areas for improvement and optimization.

First, I'll summarize what I understand about the project:

### Project Overview
"Deep Wordsmith" appears to be a premium digital thesaurus tool that leverages AI to provide contextual word suggestions and visual mnemonics. It's built with:
- Next.js 15 with App Router
- React 19
- Tailwind CSS with a custom glassmorphic design system
- Radix UI components
- Multiple AI integrations:
  - Replicate/Flux for image generation
  - Perplexity API for contextual language understanding
  - Grok API for creative word suggestions
- Zustand for state management
- TypeScript

The project appears to be in development, with some basic functionality implemented and some configuration issues that have been resolved.

### Key Areas to Analyze
1. Project structure and organization
2. Code quality and best practices
3. Performance optimizations
4. Security considerations
5. Error handling and fallbacks
6. Configuration and deployment setup
7. UI/UX improvements

Let's go through each of these areas to identify potential improvements:

### 1. Project Structure and Organization

From the code snippets, I can see:
- There's a standard Next.js App Router structure
- There are utility scripts for testing API integration
- There's a verification script for deployment
- There are fallback images for when API calls fail

Potential improvements:
- The organization seems decent, but I don't see clear indication of domain-driven design or clear separation of concerns in the components
- There might be a need for better organization of API-related code (adapters, services, etc.)
- TypeScript types could potentially be better organized

### 2. Code Quality and Best Practices

From the snippets:
- There's good use of TypeScript
- There's some error handling in place, especially for the API integrations
- There's configuration for ESLint and other tools

Potential improvements:
- Add more comprehensive type definitions for API responses
- Implement consistent error handling across all components and API calls
- Add more comprehensive testing (unit tests, integration tests, E2E tests)
- Consider using a more robust form handling library (like React Hook Form) if there are forms in the application

### 3. Performance Optimizations

Potential improvements:
- Implement better caching strategies for API calls, especially for image generation
- Optimize image loading with proper sizes, formats, and lazy loading
- Implement virtualization for large lists of words/suggestions
- Use React Server Components where appropriate to reduce client-side JavaScript
- Implement proper code splitting

### 4. Security Considerations

Potential improvements:
- Ensure all API keys are properly secured
- Implement proper CORS policies
- Add rate limiting to API endpoints
- Sanitize user inputs

### 5. Error Handling and Fallbacks

From the snippets:
- There's some error handling for API calls
- There are fallback images configured

Potential improvements:
- Implement more comprehensive error boundaries
- Add more specific error messages and recovery strategies
- Enhance logging for errors

### 6. Configuration and Deployment Setup

From the snippets:
- There's a verification script for deployment
- There's configuration for environment variables

Potential improvements:
- Streamline the environment variable management
- Add CI/CD setup (GitHub Actions, etc.)
- Implement feature flags for gradual rollouts
- Consider containerization for consistent environments

### 7. UI/UX Improvements

Potential improvements:
- Implement loading states for all async operations
- Add more animations and transitions for a premium feel
- Ensure full accessibility compliance
- Implement keyboard shortcuts for power users
- Enhance mobile responsiveness

Let me look at the specific code snippets to identify more concrete issues and improvements:

1. From the scripts/test-flux-api.ts:
   - The code is using the Replicate API but there seems to be some confusion about whether it's using "Flux" or "Replicate" (variable names and comments mix these)
   - Error handling seems basic
   - The prompt enhancement seems hardcoded rather than configurable

2. From the package.json:
   - The project is using very recent versions of React (19) and Next.js (15.1.7) which might have stability issues
   - There's a custom build script to bypass ESLint checks, which might indicate linting issues that should be properly fixed
   - Legacy peer dependencies flag might indicate dependency conflicts

3. From the README.md:
   - The README is quite comprehensive, which is good
   - Instructions include using legacy-peer-deps which might indicate dependency conflicts
   - The roadmap is good but could be more specific about timelines and priorities

Let me formulate some specific recommendations for improvements based on this analysis:

Recommendations for Improvements:
1. **Code Organization and Architecture**:
   - Implement a clearer domain-driven design structure
   - Separate API calls into service layers
   - Organize TypeScript types into dedicated files

2. **Performance Optimizations**:
   - Implement a more robust caching strategy for API calls
   - Add proper image optimization
   - Use React Server Components for data fetching
   - Implement virtualization for large lists

3. **Error Handling and Reliability**:
   - Add comprehensive error boundaries
   - Enhance fallback strategies
   - Implement retry mechanisms for API calls
   - Add better logging

4. **Developer Experience**:
   - Fix ESLint issues rather than bypassing them
   - Resolve dependency conflicts
   - Add more comprehensive testing
   - Enhance documentation

5. **User Experience**:
   - Improve loading states
   - Add animations and transitions
   - Ensure full accessibility
   - Enhance mobile experience

6. **Deployment and DevOps**:
   - Set up proper CI/CD
   - Improve environment variable management
   - Add monitoring and analytics
   - Implement feature flags

Now, I'll craft a command prompt for the Cursor AI composer that addresses these areas of improvement:
</think>

# Deep Wordsmith Project Analysis

After analyzing the Deep Wordsmith codebase, I've identified several areas for improvement that would enhance performance, reliability, and maintainability.

## Key Observations

1. **API Integration Confusion**: There's inconsistency between Flux and Replicate API naming in the code (the test script uses both terms interchangeably)

2. **Configuration Management**: Environment variables are handled through multiple approaches (`.env.local`, `.env.production`)

3. **Error Handling**: While basic error handling exists, it could be more robust and consistent

4. **Build Process**: ESLint checks are being bypassed rather than fixed properly

5. **Dependency Management**: The use of `--legacy-peer-deps` suggests potential compatibility issues

6. **Performance Considerations**: No clear caching strategy for expensive API calls

## Suggested Optimizations

1. **Unified API Service Layer**: Create a dedicated API services directory

2. **Enhanced Caching Strategy**: Implement SWR or React Query for data fetching

3. **Improved Error Boundaries**: Add React Error Boundaries around key components

4. **Fix ESLint Issues**: Address actual linting issues rather than bypassing them

5. **Streamlined Environment Variable Management**: Use Vercel's integrated approach

6. **Add Comprehensive Testing**: Include unit and integration tests

## Command Prompt for Cursor AI Composer

```
Improve the Deep Wordsmith project by implementing the following enhancements:

1. Create a unified API service layer in src/lib/api/ with separate files for each service:
   - flux-service.ts for image generation
   - perplexity-service.ts for contextual language
   - grok-service.ts for creative suggestions
   Each should use consistent error handling, logging, and typescript interfaces.

2. Implement a React Query or SWR caching strategy for all API calls, with:
   - Configurable stale times for different endpoints
   - Proper invalidation strategies
   - Optimistic updates where appropriate

3. Add React Error Boundaries around main application components with:
   - Fallback UI components
   - Error logging service integration
   - Recovery mechanisms

4. Fix ESLint issues properly instead of bypassing checks:
   - Update the .eslintrc.json file with appropriate rules
   - Fix actual code issues rather than disabling rules
   - Add pre-commit hooks to ensure code quality

5. Create a robust loading state management system:
   - Add loading skeletons for all async operations
   - Implement a global loading indicator for navigation
   - Add transition animations between states

6. Enhance the environment variable setup for Vercel deployment:
   - Create a proper .env.local.example template
   - Document all required variables in README.md
   - Set up a CI/CD workflow with GitHub Actions

Include consistent documentation, TypeScript interfaces, and unit tests for all new code.
```

This prompt focuses on architectural improvements that will make the codebase more maintainable, reliable, and performant without changing the core functionality. It addresses the key areas where the current implementation could be strengthened.

---



---

```


ğŸŸ¦ File: src/types/semantic-graph.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Semantic Graph Types
 *
 * Type definitions for the semantic clustering visualization feature.
 * These types define the data structure for representing word relationships
 * in a graph format that can be visualized using D3.js or react-force-graph.
 */

/**
 * Represents a node in the semantic graph (a word or concept)
 */
export interface SemanticNode {
  id: string;          // Unique identifier for the node
  word: string;        // The actual word
  type: 'primary' | 'synonym' | 'antonym' | 'related' | 'root';  // Type of node
  weight: number;      // Relationship strength (0-1)
  definitions?: string[];  // Optional definitions
  etymology?: string;  // Optional etymology information
  color?: string;      // Optional color for visualization
}

/**
 * Represents a link between two nodes in the semantic graph
 */
export interface SemanticLink {
  source: string;      // Source node ID
  target: string;      // Target node ID
  type: 'synonym' | 'antonym' | 'related' | 'derivation';  // Type of relationship
  weight: number;      // Relationship strength (0-1)
  color?: string;      // Optional color for visualization
}

/**
 * Represents the complete semantic graph structure
 */
export interface SemanticGraph {
  nodes: SemanticNode[];  // Array of nodes
  links: SemanticLink[];  // Array of links between nodes
}

/**
 * Configuration options for the semantic graph visualization
 */
export interface SemanticGraphConfig {
  minNodeSize: number;    // Minimum node size
  maxNodeSize: number;    // Maximum node size
  minLinkWidth: number;   // Minimum link width
  maxLinkWidth: number;   // Maximum link width
  nodeColorMap: Record<SemanticNode['type'], string>;  // Color mapping for node types
  linkColorMap: Record<SemanticLink['type'], string>;  // Color mapping for link types
  defaultNodeColor: string;  // Default node color
  defaultLinkColor: string;  // Default link color
}

/**
 * Default configuration for semantic graph visualization
 */
export const DEFAULT_GRAPH_CONFIG: SemanticGraphConfig = {
  minNodeSize: 4,
  maxNodeSize: 12,
  minLinkWidth: 1,
  maxLinkWidth: 3,
  nodeColorMap: {
    primary: '#6366f1',  // Indigo
    synonym: '#8b5cf6',  // Violet
    antonym: '#ec4899',  // Pink
    related: '#10b981',  // Emerald
    root: '#f59e0b',     // Amber
  },
  linkColorMap: {
    synonym: '#8b5cf6',  // Violet
    antonym: '#ec4899',  // Pink
    related: '#10b981',  // Emerald
    derivation: '#f59e0b',  // Amber
  },
  defaultNodeColor: '#6366f1',  // Indigo
  defaultLinkColor: '#94a3b8',  // Slate
};```


ğŸŸ¦ File: src/types/global.d.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Global type declarations for the application
 */

// Google Analytics gtag function
interface Window {
  gtag?: (
    command: 'event' | 'config' | 'consent' | 'set',
    action: string,
    options?: Record<string, any>
  ) => void;

  // Add other global libraries as needed
  Sentry?: {
    captureException: (error: Error) => void;
    captureMessage: (message: string) => void;
  };
}

// Extend process.env with our environment variables
declare namespace NodeJS {
  interface ProcessEnv {
    NEXT_PUBLIC_GA_MEASUREMENT_ID?: string;
    NEXT_PUBLIC_ENABLE_ANALYTICS?: string;

    // API Keys (for development type checking)
    REPLICATE_API_TOKEN?: string;
    REPLICATE_FLUX_MODEL?: string;
    PERPLEXITY_API_KEY?: string;
    GROK_API_KEY?: string;
    ANTHROPIC_API_KEY?: string;
  }
}```


ğŸŸ¦ File: src/lib/utils.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Utility function to merge class names with Tailwind CSS
 *
 * This combines clsx for conditional class names and tailwind-merge
 * to properly handle Tailwind CSS class conflicts
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Formats a date to a readable string
 * @param date - Date to format
 * @returns Formatted date string
 */
export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
  }).format(date);
}

/**
 * Delays execution for a specified time
 * @param ms - Milliseconds to delay
 * @returns Promise that resolves after the delay
 */
export function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Truncates a string to a maximum length with ellipsis
 * @param str - String to truncate
 * @param maxLength - Maximum length
 * @returns Truncated string
 */
export function truncateString(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength) + "...";
}

/**
 * Creates a debounced function that delays invoking the provided function
 * @param func - Function to debounce
 * @param wait - Wait time in milliseconds
 * @returns Debounced function
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;

  return function(...args: Parameters<T>): void {
    const later = () => {
      timeout = null;
      func(...args);
    };

    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}```


ğŸŸ¦ File: src/lib/swr-config.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * SWR Configuration
 * Global configuration for SWR data fetching and caching
 */
import { SWRConfiguration } from 'swr';

/**
 * Default global SWR configuration
 */
export const SWR_CONFIG: SWRConfiguration = {
  // Default interval in milliseconds to refresh data (0 = disabled)
  refreshInterval: 0,

  // Time in milliseconds after which data is considered stale
  // 5 minutes for most data
  dedupingInterval: 300000,

  // Whether to revalidate on focus (when tab becomes active)
  revalidateOnFocus: false,

  // Whether to revalidate on reconnect (when browser regains connection)
  revalidateOnReconnect: true,

  // Error retry settings
  errorRetryCount: 3,

  // Use localStorage for persistence (implemented via custom cache below)
  // This is handled automatically by SWR
};

/**
 * SWR configuration for image-related data
 * Uses more aggressive caching since images don't change often
 */
export const IMAGE_SWR_CONFIG: SWRConfiguration = {
  ...SWR_CONFIG,
  dedupingInterval: 3600000, // 1 hour
  errorRetryCount: 2,
};

/**
 * SWR configuration for language-related data
 * Uses less aggressive caching since language data can change
 */
export const LANGUAGE_SWR_CONFIG: SWRConfiguration = {
  ...SWR_CONFIG,
  dedupingInterval: 120000, // 2 minutes
  revalidateOnFocus: true,
};```


ğŸŸ¦ File: src/lib/error-handling/error-boundaries.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```tsx
'use client';

import { ErrorBoundary as ReactErrorBoundary, FallbackProps } from 'react-error-boundary';
import { ErrorFallback } from '@/components/error-boundary/error-fallback';
import { Button } from '@/components/ui/button';

/**
 * GlobalErrorBoundary Component
 *
 * Top-level error boundary that catches errors across the entire application.
 * Provides a full-screen fallback UI when uncaught errors occur.
 *
 * @param children - React components to be protected by this error boundary
 */
export function GlobalErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ReactErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <ErrorFallback
          error={error}
          resetErrorBoundary={resetErrorBoundary}
          className="h-screen w-screen"
          title="Application Error"
          subtitle="We've encountered an unexpected error in the application"
        />
      )}
      onError={(error, info) => {
        // Log error to console with component stack trace for debugging
        console.error('ğŸ”´ Global Error Boundary caught an error:', error);
        console.error('Component Stack:', info.componentStack);

        // Send to analytics in production
        if (typeof window !== 'undefined' && process.env.NODE_ENV === 'production') {
          window.gtag?.('event', 'exception', {
            description: error.message,
            fatal: true,
            componentStack: info.componentStack
          });
        }
      }}
      onReset={() => {
        // Optional: Perform any cleanup or state reset when the error boundary is reset
        console.log('ğŸ”„ Global error boundary has been reset');
      }}
    >
      {children}
    </ReactErrorBoundary>
  );
}

/**
 * SectionalErrorBoundary Component
 *
 * Component-level error boundary that isolates errors to specific sections of the UI.
 * Prevents the entire application from crashing when a component fails.
 *
 * @param children - React components to be protected by this error boundary
 */
export function SectionalErrorBoundary({
  children,
  customFallback,
}: {
  children: React.ReactNode;
  customFallback?: React.ComponentType<{ error: Error; resetErrorBoundary: () => void }>;
}) {
  return (
    <ReactErrorBoundary
      FallbackComponent={customFallback || (({ error, resetErrorBoundary }) => (
        <ErrorFallback
          error={error}
          resetErrorBoundary={resetErrorBoundary}
          className="glass-effect p-6 rounded-xl"
          title="Component Error"
          subtitle="This section encountered an error"
        />
      ))}
      onError={(error, info) => {
        // Log error to console with component stack trace
        console.error('ğŸŸ  Sectional Error Boundary caught an error:', error);
        console.error('Component Stack:', info.componentStack);

        // For more detailed diagnostic information in development
        if (process.env.NODE_ENV === 'development') {
          console.log('Error details:', {
            message: error.message,
            name: error.name,
            stack: error.stack,
            componentStack: info.componentStack
          });
        }
      }}
    >
      {children}
    </ReactErrorBoundary>
  );
}

/**
 * ApiErrorBoundary Component
 *
 * Specialized error boundary for API-dependent components.
 * Provides functionality to retry API calls when errors occur.
 *
 * @param children - React components to be protected by this error boundary
 * @param fallbackData - Optional fallback data to display when an API error occurs
 */
export function ApiErrorBoundary({
  children,
  fallbackData,
  onError
}: {
  children: React.ReactNode;
  fallbackData?: any;
  onError?: (error: Error) => void;
}) {
  return (
    <ReactErrorBoundary
      fallbackRender={({ error, resetErrorBoundary }: FallbackProps) => {
        // If fallback data is provided, render the children with the fallback data
        if (fallbackData) {
          return (
            <div className="relative">
              {/* We would actually use fallbackData here in a real implementation */}
              <div className="absolute top-0 right-0 p-2">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={resetErrorBoundary}
                  className="text-xs bg-yellow-500/10 hover:bg-yellow-500/20 text-yellow-700 dark:text-yellow-400"
                >
                  Using cached data. Retry?
                </Button>
              </div>
            </div>
          );
        }

        // Otherwise, render the default error UI
        return (
          <ErrorFallback
            error={error}
            resetErrorBoundary={resetErrorBoundary}
            className="glass-effect p-4 rounded-lg"
            title="API Error"
            subtitle="We couldn't load this data"
            showDetails={process.env.NODE_ENV === 'development'}
          />
        );
      }}
      onError={(error) => {
        console.error('ğŸ”µ API Error Boundary caught an error:', error);
        if (onError) onError(error);
      }}
    >
      {children}
    </ReactErrorBoundary>
  );
}```


ğŸŸ¦ File: src/lib/env.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Environment Variable Utilities
 *
 * This module provides safe access to environment variables with proper typing and validation.
 */

/**
 * Get an environment variable with validation
 *
 * @param key The environment variable key
 * @param defaultValue Optional default value if not found
 * @param required Whether the environment variable is required
 * @returns The environment variable value or default
 */
export function getEnv(
  key: string,
  defaultValue?: string,
  required = false
): string | undefined {
  const value = process.env[key];

  // Log the status in development for debugging
  if (process.env.NODE_ENV === 'development') {
    if (!value) {
      console.warn(`âš ï¸ Environment variable ${key} not found${required ? ' (REQUIRED)' : ''}`);
    } else {
      console.log(`âœ… Environment variable ${key} loaded successfully`);
    }
  }

  // If the value is required but not found, throw an error
  if (required && !value && !defaultValue) {
    throw new Error(`Required environment variable ${key} is missing`);
  }

  return value || defaultValue;
}

/**
 * Get a boolean environment variable
 *
 * @param key The environment variable key
 * @param defaultValue Default value if not found
 * @returns The boolean value
 */
export function getBoolEnv(key: string, defaultValue = false): boolean {
  const value = getEnv(key);
  if (value === undefined) return defaultValue;
  return value.toLowerCase() === 'true';
}

/**
 * Get a required environment variable
 *
 * @param key The environment variable key
 * @throws Error if the environment variable is not found
 * @returns The environment variable value
 */
export function getRequiredEnv(key: string): string {
  const value = getEnv(key, undefined, true);
  if (!value) {
    throw new Error(`Required environment variable ${key} is missing`);
  }
  return value;
}

/**
 * Get a number environment variable
 *
 * @param key The environment variable key
 * @param defaultValue Default value if not found
 * @returns The number value
 */
export function getNumberEnv(key: string, defaultValue?: number): number | undefined {
  const value = getEnv(key);
  if (value === undefined) return defaultValue;
  const num = Number(value);
  return isNaN(num) ? defaultValue : num;
}```


ğŸŸ¦ File: src/lib/env-validator.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
import { getEnv } from './env';

/**
 * Environment Variable Validator
 *
 * Ensures all required environment variables are present before application startup
 */

// Define required environment variables for each AI service
export const REQUIRED_ENV_VARS = {
  // Replicate (for image generation)
  replicate: ['REPLICATE_API_TOKEN', 'REPLICATE_FLUX_MODEL'],

  // Perplexity (for contextual understanding)
  perplexity: ['PERPLEXITY_API_KEY'],

  // Grok (for creative suggestions)
  grok: ['GROK_API_KEY'],

  // Anthropic (for linguistic analysis)
  anthropic: ['ANTHROPIC_API_KEY'],
} as const;

// Define service key type
export type ServiceKey = keyof typeof REQUIRED_ENV_VARS;

// Check if a specific service's environment variables are present
export function validateServiceEnv(service: ServiceKey): {
  valid: boolean;
  missing: string[];
  serviceName: string;
} {
  const requiredVars = REQUIRED_ENV_VARS[service];
  const missing = requiredVars.filter(varName => !process.env[varName]);

  return {
    valid: missing.length === 0,
    missing,
    serviceName: service,
  };
}

// Validate all environment variables or a specific set
export function validateEnv(services?: ServiceKey[]): {
  valid: boolean;
  missing: Record<string, string[]>;
} {
  const servicesToValidate = services || Object.keys(REQUIRED_ENV_VARS) as ServiceKey[];

  const result: Record<string, string[]> = {};
  let valid = true;

  for (const service of servicesToValidate) {
    const validation = validateServiceEnv(service);
    if (!validation.valid) {
      valid = false;
      result[service] = validation.missing;
    }
  }

  // Log validation results in development
  if (process.env.NODE_ENV === 'development' && !valid) {
    console.error('âŒ Missing required environment variables:');
    Object.entries(result).forEach(([service, vars]) => {
      console.error(`  - ${service}: ${vars.join(', ')}`);
    });
    console.error('Please add these variables to your .env.local file');
  }

  return {
    valid,
    missing: result,
  };
}

// Validate all environment variables and throw if in production
export function validateEnvOrThrow(throwInProduction = true): void {
  const { valid, missing } = validateEnv();

  if (!valid && (process.env.NODE_ENV === 'production' && throwInProduction)) {
    throw new Error(
      `Missing required environment variables: ${JSON.stringify(missing)}`
    );
  }
}

/**
 * Environment Validator Utility
 *
 * Validates that all required environment variables are present
 * and logs warnings for missing variables.
 */

// List of API keys that should be present (but can be missing in development)
const API_KEYS = [
  'REPLICATE_API_TOKEN',
  'PERPLEXITY_API_KEY',
  'GROK_API_KEY',
  'ANTHROPIC_API_KEY',
];

// List of absolutely required environment variables (will throw error if missing)
const REQUIRED_VARS = [
  'NEXT_PUBLIC_APP_URL',
];

/**
 * Validates that all required environment variables are present
 * @param strict Whether to throw errors for missing API keys (default: false)
 */
export function validateEnvironment(strict = false): void {
  // Check required environment variables
  REQUIRED_VARS.forEach(key => {
    try {
      const value = getEnv(key, undefined, true);
      if (!value) {
        throw new Error(`Required environment variable ${key} is missing`);
      }
    } catch (error) {
      console.error(`âŒ ${error}`);
      throw error;
    }
  });

  // Check API keys
  const missingApiKeys = API_KEYS.filter(key => !process.env[key]);

  if (missingApiKeys.length > 0) {
    console.warn(`âš ï¸ Missing the following API keys: ${missingApiKeys.join(', ')}`);

    if (process.env.NODE_ENV === 'production' && strict) {
      throw new Error(
        `Missing required API keys in production: ${missingApiKeys.join(', ')}`
      );
    }
  } else {
    console.log('âœ… All API keys are configured');
  }
}

/**
 * Validate environment variables at runtime
 * but don't throw errors in development mode
 */
export function validateRuntimeEnvironment(): void {
  try {
    validateEnvironment(process.env.NODE_ENV === 'production');
  } catch (error) {
    // In development, just log the error
    if (process.env.NODE_ENV !== 'production') {
      console.error(`Environment validation failed: ${error}`);
      return;
    }

    // In production, rethrow the error
    throw error;
  }
}```


ğŸŸ¦ File: src/lib/env-validation.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Environment Variable Validation
 *
 * Advanced validation for environment variables using zod schema validation.
 * Ensures that required variables are present and properly formatted before
 * application startup.
 */

import { z } from 'zod';

// Define schema for environment variables
const envSchema = z.object({
  // Core app settings
  NEXT_PUBLIC_APP_URL: z.string().url().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),

  // API keys with format validation where possible
  REPLICATE_API_TOKEN: z.string().min(1, "Replicate API Token is required"),
  REPLICATE_FLUX_MODEL: z.string().min(1, "Replicate Flux Model ID is required"),

  PERPLEXITY_API_KEY: z.string().min(1, "Perplexity API Key is required"),

  GROK_API_KEY: z.string().min(1, "Grok API Key is required"),

  ANTHROPIC_API_KEY: z.string()
    .min(1, "Anthropic API Key is required")
    .regex(/^sk-ant-/, "Anthropic API Key must start with sk-ant-"),

  // Optional settings with defaults
  API_TIMEOUT_MS: z.coerce.number().positive().default(30000),
  DEBUG_LOGGING: z.enum(['true', 'false']).default('false'),
});

// Define the environment type based on the schema
export type Env = z.infer<typeof envSchema>;

/**
 * Validate all environment variables against the schema
 * @param exitOnFailure Whether to exit the process on validation failure
 * @returns Validated environment variables object
 */
export function validateEnv(exitOnFailure = false): Env {
  try {
    // Parse environment variables with the schema
    const env = envSchema.parse(process.env);
    console.log('âœ… Environment validation successful');
    return env;
  } catch (error) {
    console.error('âŒ Environment validation failed:');

    if (error instanceof z.ZodError) {
      const issues = error.errors.map(issue => {
        const path = issue.path.join('.');
        return `  - ${path}: ${issue.message}`;
      }).join('\n');

      console.error(issues);

      if (exitOnFailure && process.env.NODE_ENV === 'production') {
        console.error('Exiting process due to missing required environment variables');
        process.exit(1);
      }
    } else {
      console.error('  Unknown validation error:', error);
    }

    // Return a partial environment with just the NODE_ENV for minimal operation
    // This allows the app to run in development mode with missing variables
    if (process.env.NODE_ENV !== 'production') {
      return {
        NODE_ENV: process.env.NODE_ENV as 'development' | 'production' | 'test' || 'development',
        API_TIMEOUT_MS: 30000,
        DEBUG_LOGGING: 'false',
      } as Env;
    }

    throw error;
  }
}

/**
 * Validate a specific service's environment variables
 * @param service The service to validate
 * @returns Whether all required variables for the service are present
 */
export function validateServiceEnv(service: 'replicate' | 'perplexity' | 'grok' | 'anthropic'): boolean {
  try {
    const partialSchema = {
      replicate: z.object({
        REPLICATE_API_TOKEN: envSchema.shape.REPLICATE_API_TOKEN,
        REPLICATE_FLUX_MODEL: envSchema.shape.REPLICATE_FLUX_MODEL,
      }),
      perplexity: z.object({
        PERPLEXITY_API_KEY: envSchema.shape.PERPLEXITY_API_KEY,
      }),
      grok: z.object({
        GROK_API_KEY: envSchema.shape.GROK_API_KEY,
      }),
      anthropic: z.object({
        ANTHROPIC_API_KEY: envSchema.shape.ANTHROPIC_API_KEY,
      }),
    };

    // Validate just the service-specific variables
    partialSchema[service].parse(process.env);
    return true;
  } catch (error) {
    if (error instanceof z.ZodError) {
      const missingVars = error.errors.map(e => e.path.join('.'));
      console.warn(`âš ï¸ Service "${service}" has missing environment variables:`, missingVars);
    }
    return false;
  }
}

/**
 * Initialize environment validation on application startup
 * In production, this will exit the process if required variables are missing
 */
export function initializeEnvValidation(): void {
  const shouldExitOnFailure = process.env.NODE_ENV === 'production';
  validateEnv(shouldExitOnFailure);
}```


ğŸŸ¦ File: src/lib/api/mocks/grok-mocks.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```ts
/**
 * Grok Service Mock Data
 *
 * Provides fallback mock data for the Grok API when it is unavailable.
 * Used by the circuit breaker pattern to maintain functionality during API outages.
 */

export interface SuggestionItem {
  word: string;
  type: string;
  score: number;
  definition?: string;
  examples?: string[];
}

export interface SuggestionResponse {
  suggestions: SuggestionItem[];
  metadata: {
    model: string;
    requestedWord: string;
    totalResults: number;
  };
}

/**
 * Generates mock word suggestions as a fallback when the API is unavailable
 * @param word The input word to generate suggestions for
 * @returns Mock suggestion response
 */
export function mockGrokSuggestions(word: string): SuggestionResponse {
  // Common prefixes and suffixes for generating plausible related words
  const prefixes = ['re', 'un', 'in', 'dis', 'over', 'under', 'pre', 'post', 'anti'];
  const suffixes = ['ness', 'ity', 'tion', 'ing', 'ed', 'ly', 'ful', 'less', 'able', 'ible'];

  // Word types
  const types = ['synonym', 'antonym', 'related', 'derivative', 'example-usage'];

  // Generate random related words
  const suggestions: SuggestionItem[] = [];

  // Add a few synonyms
  suggestions.push({
    word: `${prefixes[Math.floor(Math.random() * prefixes.length)]}${word}`,
    type: 'synonym',
    score: 0.9,
    definition: `Similar in meaning to ${word}`,
    examples: [`The ${word} was impressive.`]
  });

  suggestions.push({
    word: `${word}${suffixes[Math.floor(Math.random() * suffixes.length)]}`,
    type: 'derivative',
    score: 0.85,
    definition: `Derived from ${word}`,
    examples: [`They expressed great ${word}${suffixes[0]}.`]
  });

  suggestions.push({
    word: `alternative_${word}`,
    type: 'synonym',
    score: 0.8,
    definition: `Another term for ${word}`,
    examples: [`The alternative_${word} provided a new perspective.`]
  });

  suggestions.push({
    word: `opposite_${word}`,
    type: 'antonym',
    score: 0.75,
    definition: `Opposite in meaning to ${word}`,
    examples: [`While some prefer ${word}, others choose opposite_${word}.`]
  });

  suggestions.push({
    word: `${word}_concept`,
    type: 'related',
    score: 0.7,
    definition: `Conceptually related to ${word}`,
    examples: [`The ${word}_concept is fundamental to understanding this field.`]
  });

  // Include common, realistic fallback for certain words
  const commonWords: Record<string, SuggestionItem[]> = {
    'happy': [
      { word: 'joyful', type: 'synonym', score: 0.95, definition: 'Feeling or showing great pleasure or happiness', examples: ['She was joyful about the news.'] },
      { word: 'content', type: 'synonym', score: 0.9, definition: 'In a state of peaceful happiness', examples: ['He felt content with his life.'] },
      { word: 'sad', type: 'antonym', score: 0.85, definition: 'Feeling or showing sorrow', examples: ['He looked sad when he heard the bad news.'] }
    ],
    'sad': [
      { word: 'unhappy', type: 'synonym', score: 0.95, definition: 'Not happy; sorrowful', examples: ['She was unhappy with the results.'] },
      { word: 'melancholy', type: 'synonym', score: 0.9, definition: 'A feeling of pensive sadness', examples: ['There was a melancholy atmosphere at the farewell party.'] },
      { word: 'happy', type: 'antonym', score: 0.85, definition: 'Feeling or showing pleasure or contentment', examples: ["I'm happy to see you."] }
    ],
    'good': [
      { word: 'excellent', type: 'synonym', score: 0.95, definition: 'Extremely good; outstanding', examples: ['The food was excellent.'] },
      { word: 'fine', type: 'synonym', score: 0.9, definition: 'Of high quality', examples: ["That's a fine piece of craftsmanship."] },
      { word: 'bad', type: 'antonym', score: 0.85, definition: 'Not good in quality or condition', examples: ['The movie was really bad.'] }
    ],
    'bad': [
      { word: 'poor', type: 'synonym', score: 0.95, definition: 'Of low or inferior standard or quality', examples: ['The poor quality of the recording made it difficult to hear.'] },
      { word: 'awful', type: 'synonym', score: 0.9, definition: 'Very bad or unpleasant', examples: ['The weather was awful yesterday.'] },
      { word: 'good', type: 'antonym', score: 0.85, definition: 'To be desired or approved of', examples: ['The soup tastes good.'] }
    ],
    'big': [
      { word: 'large', type: 'synonym', score: 0.95, definition: 'Of considerable or relatively great size', examples: ['They have a large house.'] },
      { word: 'enormous', type: 'synonym', score: 0.9, definition: 'Very large in size or amount', examples: ['He made an enormous mistake.'] },
      { word: 'small', type: 'antonym', score: 0.85, definition: 'Of a size that is less than normal or usual', examples: ['She has small hands.'] }
    ]
  };

  // Check if we have predefined suggestions for this word
  const normalizedWord = word.toLowerCase().trim();
  if (commonWords[normalizedWord]) {
    return {
      suggestions: commonWords[normalizedWord],
      metadata: {
        model: 'offline-fallback-model',
        requestedWord: word,
        totalResults: commonWords[normalizedWord].length
      }
    };
  }

  // Return generated suggestions
  return {
    suggestions,
    metadata: {
      model: 'offline-fallback-model',
      requestedWord: word,
      totalResults: suggestions.length
    }
  };
}

/**
 * Get mock word analysis with etymology and usage examples
 * @param word The input word to analyze
 * @returns Mock word analysis
 */
export function mockWordAnalysis(word: string) {
  return {
    word,
    etymology: `[OFFLINE MOCK] The word "${word}" likely originates from the Old English language.`,
    definition: `[OFFLINE MOCK] A general term describing the concept of ${word}`,
    usageExamples: [
      `[MOCK] Many people use ${word} in everyday conversations.`,
      `[MOCK] The concept of ${word} has evolved over time.`,
      `[MOCK] Scholars have debated the meaning of ${word} for centuries.`
    ],
    relatedConcepts: [
      `${word}ology`,
      `${word} theory`,
      `${word} practice`
    ],
    offlineGenerated: true
  };
}```

ğŸ“Š Dump Statistics
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total words: 0
Estimated tokens: 0
Generated on: Tue Feb 25 05:23:07 PST 2025
